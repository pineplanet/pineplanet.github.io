---
title: TIL 2021-11-15 Spring boot 강의 3 (김영한 선생님) & spring mvc annotation
tags: [TIL, JAVA, SPRING]
categories: TIL
---
# 오늘 배운 것 
- 어제 밤에 잠이 안와서 객체 지향의 사실과 오해 를 리디북스로 읽기 시작했습니다. 
- 객체 지향은 클래스를 지향하라는 것이 아니라, 객체 그 자체를 보라는 것이라는 말과 
- 커피 공화국 사람들에 빗대어서 객체를 설명 하시면서 사실 실세계와 객체 세계의 거리는 멀다. 프로그래밍은 실 세계를 모방하는 것이 아니고, 새로운 세계의 창조이다. 라고 하셨던 말씀이 계속 맴돕니다. 
- 프로그램은 객체들의 모임이고, 이 객체들은 메시지를 주고 받으면서 각자의 책임을 다하기 위해 성실하게 역할을 수행 합니다. 
  - 이들이 역할을 다하기 위해선 혼자서 모든 책임을 다 질 수는 없고 (내부적 복잡성 문제) 
  - 다른 객체에게 책임을 위임하기도 하는데, 
  - 위임한다고 해서 타율적이라는 것은 아닙니다. 위임받은 일을 처리하는 방식과 처리 여부는 객체 스스로 선택 합니다. 
  - 객체 각각은 다른 객체로 부터 독립적으로 존재하고, 자율성을 갖추고 있습니다. 
  - 스스로의 역할을 하기 위해 갖춰야할 자격  ( 상태와 행동 방식(?)) 을 갖추고 있어요.
  
- 김영한 선생님 강의 
  - 스프링이 나오기 전까지의 프로그래밍 방식은 좋은 객체 지향 프로그래밍 원칙을 모두 지킬 수 가 없습니다. 
  - 결국 개방 폐쇄, 의존관계 역전 원칙 을 지킬 수 가 없어요. 
  - 뭔가 연결해주는 껍데기 를 하나더 만들면 되지 않을까요? 라고 생각 했는데 그거시 바로 결국 스프링...
  - Long 은 long 으로 써도 되지만 , long 으로 쓰면 null을 쓰지 못함;
  - 객체 지향 원칙을 지키기 위해 Config 등장과 Spring에 드디어 올려보았습니다. 
  - Spring Container 의의와 생성에 대해 공부 하였습니다. 
  
  
- 맥북 메모리 관리 
  - 맥북은 메모리 관리를 알아서 잘해주겠지 라는 생각이 있었고, 사용하면서 문제 있었던 적이 없어서 관리 필요성 자체를 느낀적은 없었는데 강의를 듣다보니 테스트할때 제 맥이 느리구나(?)하는 생각이 들었어요 .
  - 활성 상태 보기로 살펴보았더니, 물리적메모리는 8GB인데, 사용된 메모리는 6기가 가 넘었어요. 띠용. 
    - (참고) 활성 상태 보기 
      - 물리적 메모리 : 맥에 장착된 메모리 하드웨어 총량 
      - 사용된 메모리 : 현재 컴퓨터가 사용하고 있는 메모리 총량 
        - 앱 메모리: 응용 프로그램이 차지(캐시 및 압축 가능 )
        - 와이어드 메모리: 시스템이 차지 ( 불가능 )
        - 압축됨: 물리 메모리량 < 사용된 메모리량인 상황에서 RAM 에 남아있는 가장 오래된 메모리를 압축 해서 가용 공간을 늘리고, SSD 로 스왑 하지 않도록 막아줍니다.
      - 캐시된 파일 : 자주 사용, 최근 사용한 응용 프로그램의 정보를 SSD 가 아닌 RAM 의 공간에 일부 할당 해서, 빠르게 실행 하고 처리 하는데 사용 
    - 저 메모리 사용량에 충격 받고, 캐시된 파일을 모두 지우고 재부팅을 일단 하고 난 뒤, 크롬과 사파리를 메모리 비교 해서 크롬을 버렸어요. 
    - 그리고 더 찾아보니 맥은 메모리 관리를 위해서 프로그램 사용시 ** 메모리 공간을 잡아두어서**, 가용 메모리는 최대한 놀지 않게 합니다. 그리고 위와 같이 알아서 메모리 관리를 해줘요. 
    - M1 맥북의 경우에는 메모리 관리 이슈가 있긴 합니다. 
      - 메모리 누수 / 메모리 스왑으로 인한 SSD 수명 문제 논란 등 
      - 근데 뭐..지금 맥으로 천년만년 쓸 것은 아니니까요. 다음 맥 가즈아 ...
  - 느렸던 진짜 문제 는 메모리 관리 문제가 아니고, intellij 에 연동된 java 문제였어요.
    - 분명히 apple silicon 으로 돌아가는 java 버전을 사용한다고 생각햇었는데, 
    - 메모리 관리를 유심히 살펴보니, apple java 와 intel java 가 모두 올라가고 있었습니다. 
    - 그래서 기존의 java 를 모두 지우고, intellij 에서 java 버전을 선택해서 apple silicon 에 맞는 자바를 다시 다운 받아서 연결 해주었습니다. 
    - 다시 돌려보니 속도가 2배 빨라졌습니다. 예이! 
    - 이제 터미널에서 java를 정리 해줘야겠어요. 
  

        