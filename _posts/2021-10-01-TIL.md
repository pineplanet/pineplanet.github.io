---
title: TIL 2021-10-01 JAVA 객체 지향 4번째 학습!
tags: [TIL, JAVA]
categories: TIL
---
- java 객체 문제 풀이를 하면서 이번주에 배운 내용을 테스트하고 복습하였습니다. 
- 새로 배운 내용 
    - 디자인 패턴이란 객체들과 객체들간 관계를 정립할 때 적용할 수 있는 일정한 룰(?)을 말하는데 훌륭한 개발자들이 다듬어놓은 레이아웃(?)입니다. 생물학에 비유하면 웨스턴 블랏이나 ELISA 등과 같이 어떤 과학자가 만들어 놓은 방법이 표준화 되어 교과서에도 실리고, 실험실에서도 사용하는 프로토콜 느낌이고 게임에 비유하면 특정 상황에서 가장 효율이 좋은 특성 트리, 0티어 캐릭터 선발 등인 것 같습니다. 아직 와닿지는 않아서 좀 더 공부하다보면 정의가 될 것 같습니다. web 디자인 패턴으로는 MVC 가 있다고 합니다. 

    - 싱글톤 패턴이란 디자인 패턴 중의 하나 인데 메인 메소드?나 프로그램에서 단 1개의 인스턴스만을 생성하고 싶고, 여러 객체가 생성될 때 설정값이 손상되는 위험으로 부터 객체를 보호하고 싶을 때 사용합니다. 
    - 싱글톤 패턴의 예제 


    ``` java 
    
    public class Calc2 { //싱글톤 패턴
    private static Calc2 calc = new Calc2();
    private Calc2() {

    }
    public static Calc2 getInstance(){
        return calc;
    }
    public int add(int n1, int n2) {
        System.out.println(n1+n2);
        return n1 + n2;
    }

    public int mul(int n1, int n2) {
        System.out.println(n1*n2);
        return n1 * n2;
    }} 
    ```



    - 위의 코드를 보면 private을 사용해서 Calc2의 생성을 불가능하게 하고, getInstance를 사용하여 Calc2를 생성하도록 하게 되있습니다.그러니까 맨 위에 있는 private static Calc2 calc = new Calc2();에서 calc가 한번만 만들어지고, getInstance는 calc의 주소값을 리턴 하는 것 입니다. 
    - 이렇게 싱글톤 패턴을 사용하면 하나의 클래스를 공유하여 사용할 수 있고, 설정된 값이 훼손될 위험을 막을 수 있으며 유지보수에 편리하다는 장점이 있지만 여러 곳에서 하나의 클래스만을 사용하기 때문에 과부하가 걸릴 가능성이 있다는 것을 주의 하여야 한다고 합니다. 

    - 상속
        - 자바는 객체 지향 언어라는 하나의 큰 방향에서 계속 배우게 되었는데 자바 프로그램 설계시 관심 분리/중복제거/상속 이 핵심이 된다고 합니다. 그 중에서 오늘은 상속에 대해 공부하였습니다. 

        - 상속이란 여러 클래스가 동일하게 가지고 있는 특성(멤버변수, 메소드 )들을 각각 클래스에서 정의하면 야기 되는 코드 중복을 막기 위한 것입니다. 공통된 부분을 모아서 클래스를 정의 하여 부모 클래스라 하고, 부모 클래스를 가져다 쓰는 자식 클래스를 작성하여 서로 연결해주는 것을 상속한다고 합니다. 
        - 부모는 super class 라고 하며 자식은 sub class라고 하는데 Java는 python과는 달리 단일 상속 관계만 가능합니다. 
        - 상속을 할 때는 주의할 점이 있는데 부모와 자식 사이에 "Is a 관계"가 성립해야합니다. 만약 서로 다른 객체간 연결을 잘못한 채 프로그램을 작성해버리면 엉켜버릴테니까 주의 하여야합니다. 
        - 상속관계가 메모리 상에서는 어떻게 되는지도 공부하였습니다. 
            - 메인 메소드를 실행하여 상속 관계의 자식 클래스를 호출하게 되면, 해당 클래스로 찾아가서 상속관계의 부모 클래스를 찾아가게 되고, 
            - 부모 클래스의 상속관계까지 살펴 가장 조상(?ㅋㅋ)이 되는 클래스로 들어갑니다. 
            - 그리고 상위 클래스 부터 멤버 변수를 읽어서 메모리에 저장한 후 다시 아래로 내려와서 
            - 메인영역으로 가고 준비가 끝나면 메인 메소드에서 호출한 메소드가 실행 됩니다. 
        - 어제 생성자에 대해서 배워 봤는데요. 자식 클래스의 생성자와 부모 클래스의 생성자의 관계는 어떻게 되는 걸까요?! 
            - 자식 클래스의 생성자는 자동으로 작성/호출되어서 멤버변수를 초기화 해줍니다. 자식 클래스는 부모의 멤버변수를 땡겨 오니까, 부모 멤버 변수도 초기화 할 필요가 있겠지요. 그래서 자식클래스의 생성자는 super();를 숨기고 있어요....(코드를 작성하지 않아도 자바가 자동으로 컴파일 해줘요) 
            - super는 this처럼 자식 클래스에서 부모클래스의 주소값을 가지고 있습니다.
            - 어제 생성자에 대해서 배울 때 생성자도 인자값을 넣을 수 있다고 하였는데, 부모 생성자도 인자값을 넣을 수 있습니다(당연히 부모 클래스 안에서는 그냥 생성자니까요..). 그런데 여기서 주의 해야할 것은 자식 클래스의 생성자는 호출되면서 부모 클래스의 생성자도 자동으로 호출 된다고 했는데,기본적으로 super();로 돌아가니까 요부분에 인자를 삽입해주지 않으면 에러가 납니다. 이부분을 주의해야합니다. 
        - 자식 클래스에서 부모 클래스의 메소드 사용하기도 가능합니다.그리고 메소드 오버라이딩도 가능해요. 아래 Person-Student는 상속 관계의 클래스들 인데, 자식의 getInfo()가 부모의 getInfo를 오버라이딩 하도록 작성 하였습니다. 
        - 이부분은 아직 공부가 덜 되어서 좀 더 공부를 해야 할 것 같아요..오늘은 자식의 getInfo에서 super.getInfo()를 사용하여 부모 클래스의 메소드를 사용하는 것을 배웠어요. 
        ```java
        class Person { ///부모 클래스 
        String name;
        int age;
        public Person(String name,int age){
        this.name = name;
        this.age = age;
        }
        public void getInfo() {
            System.out.print(name + ":" + age + ":" );
            }
        }
        ```
        -
        ```java 
        class Student extends Person { ///자식 클래스 
            String major;

            public Student(String name, int age, String major) {
                super(name,age);
                this.major = major;
            }

            public void getInfo() { //메소드 오버라이딩 = 상속받은 메소드의 바디를 재정의
                super.getInfo();
                System.out.println(major);
            }

        }
        ```
       