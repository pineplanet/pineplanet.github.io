---
title: 강의 2021-11-16 스프링 핵심 원리 - 기본편 tags: [김영한, JAVA, SPRING]
categories: 강의
---

# 2021-11-16 공부 시작

## 강의 목표

- 스프링 본질에 대한 이해
	- 왜 스프링이 필요하고, 왜 만들어졌는지,
	- 어떻게 사용하는지
- 객체 지향 설계를 할 수 있게 성장하자.
- 아키텍쳐 까지 고려 하는 개발자가 되자.

## 스프링의 핵심 가치

- 스프링의 핵심은 객체 지향 프로그래밍에 있습니다.
- 자바를 배우기 시작하면서 부터 계속 객체 지향으로 시작해서 객체로 끝나네요.
- 아무튼 객체 지향원칙을 지킬 수 있도록 지원 하는 프레임워크 입니다.

# 객체 지향 설계와 스프링

## 2021-11-17

### 자바 진영의 추운 겨울과 스프링의 탄생 (위...윈터 다음 스프링 ...)

- 옛날 옛적에는 EJB 가 있었습니다.
	- Spring + JPA 합친 종합 선물 세트
		- 컨테이너 , 트렌젝션, 분산 기술 등에 강했습니다.
		- 엔티티빈 (ORM 기술 )
	- "표준" == "유행" ? = 비쌈
	- 쎄고 강하지만 ... 개발자들은 EJBd에 종속된 ~~노예~~가 되었습니다.
		- 믿었다가 지옥불에 떨어짐
		- 복잡하고, 어렵고, 느립니다.
	- 지친 개발자들은 순수한 자바로 돌아가자는 운동을 ...(POJO).

- 용자의 탄생
	- 로드존슨 : EJB 를 비판 하면서 단순하게 가자! 표준기술을 발표 합니다.
	- 개빈 킹 : 엔티티빈을 대체할 하이버네이트를 만듭니다.
	- JPA : 하이버네이트 를 만든 개빈 킹을 데려와서 만들었습니다.

- 스프링의 역사
	- 로드존슨이 EJB를 까면서 EJB없이도 고품질의 어플을 개발할 수 있다는 것을 보여줍니다.
	- 30000 라인의 기술을 예제코드로 보여줬는데 여기에 스프링의 핵심 기술이 들어있습니다.
	- 유겐휠러, 얀 카로프 (스프링 이름 지음 : 겨울(EJB)이 갔다! )가 프로젝트 제안 합니다.
	- (응? 우리는 처음부터 한다고요? 왜요? )
		- 개발자들의 마음을 이해하기 위해서 ....?


- 스프링의 발전
	- 1.0 : XML
	- 2.0 : XML 설정 편의 기능
	- 3.0 : 자바 코드
	- 4.0 : 자바 8 (다른가요..? )
	- 스프링 부트 출시 (2014) : 설정, 배포 어려움을 쉽게 바꿔줌
	- 5.0 & 스프링부트 2.0 : 리엑티브 프로그래밍 지원 (노드 JS 처럼 개발 )

### 스프링 이란 ?

스프링은 여러 기술의 모음 입니다.

- 스프링 ?
	- 문맥에 따라 지칭 범위가 달라집니다.
	- 스프링 DI 컨테이너
	- 스프링 프레임워크
	- 스프링 부트, 프레임워크 외 모든 것을 포함한 스프링 생태계

- 스프링 생태계
	- 필수
		- 스프링 프레임워크
			- 핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트
			- 파생 기술
		- 스프링 부트 : 스프링을 편리하게 사용할 수 있도록 지원 합니다.
			- 장점:
				- 단독 실행할 수 있는 어플리케이션 쉽게 ( 톰캣 같은 것을 따로 설정 안해도됨)
				- 쉬운 빌드 를 위한 starter 가 종속 관계 관리 해줌
				- 스프링 프레임워크 버전과 외부 라이브러리 버전들의 궁합을 정해줌
				- 모니터링 지원
				- 관례에 의한 간결한 설정 (웬만하면 디폴트..)
	- 선택
		- 스프링 데이터
		- 스프링 세션
		- 스프링 시큐리티
		- 스프링 Rest Docs
		- 스프링 배치
		- 스프링 클라우드
- 스프링을 왜 만들었는가?
	- **핵심 컨셉**
		- 자바 언어 = **객체 지향** 언어 기반의 프레임 워크 입니다.
		- 객체 지향 어플리케이션을 개발 할 수 있게 도와줍니다.
			- 좋은 객체 지향 어플리케이션이 뭐냐?
				- 객체 지향의 특징
					- 추상화 :
						- 공통의 속성, 기능을 묶어서 이름을 붙이는 것입니다.
						- 클래스를 정의 하는 것 입니다.
						- 인간, 개, 고양이를 하나로 묶는 공통적인 특성 은 포유류 입니다. 이렇게 포유류라고 붙이는 것이 추상화 입니다.

					- 캡슐화
						- 캡슐 하면 닥터 캡슐이 생각 나네요 ... ㅋㅋㅋㅋㅋㅋㅋㅋ...
						- 객체의 성질 (변수와 행위(메소드))을 함께 묶어서 외부에는 노출 되지 않도록 보호 하는 것 입니다.
					- 상속
						- 상속은 객체 간의 관계 입니다.
						- 부모 클래스의 성질을 자식 클래스가 이어 받습니다. 하지만 그 내부의 값은 변경할 수 가 있어요.
					- **다형성**
						- 다형성은 같은 이름을 붙인 것이 여러 형태 일 수 있다는 것 입니다.
						- 부여된 역할은 같아도 내부에서 동작하는 것은 서로 다르게 할 수 있는 것 입니다.
						- 롤을 할 때를 예를 들어 이해 해보았습니다.
							- 같은 팀 플레이어들의 역할은 탑, 정글, 미들, 바텀, 서포터 등으로 나눠지지요. 각자의 임무가 정해져 있습니다.
							- 그런데 플레이어가 어떤 캐릭터를 선택 하느냐에 따라 게임의 플레이가 조금씩 달라집니다.
							- 고유 스킬과 조합 해야할 아이템 등이 달라집니다. 그럼에도 역할은 바뀌지 않고 게임을 진행 합니다.
							- ~~그냥 미쳐 날뛰면 됩니다.~~
		- 그래서 객체 지향 프로그래밍이 뭔가?
			- 컴퓨터 프로그램을 객체(각자 서로 독립된 단위) 들의 모임으로 바라봅니다.
			- 이 객체들은 서로 메시지를 주고 받고 데이터를 처리합니다.
			- 객체지향 프로그래밍은 유연하고 변경이 용이 합니다.
				- 프로그램 = 레고 블럭 처럼 조립 하는 것
				- 핵심은 다형성 입니다.
		- 다형성의 실세계 비유
			- 역할과 구현으로 세상을 구분해봅시다.
				- 운전자와 자동차
					- 운전자의 역할은 자동차를 구입/선택 하고, 자동차를 작동 합니다.
					- 운전자는 자동차의 내부구조를 모르지만, 작동할 수 있고, 언제든지 자동차를 변경할 수 있습니다. **이게 진짜 중요**
					- 자동차의 역할은 운전자의 작동에 따라 이동합니다.
					- 자동차의 역할만 충실하게 따라간다면 어떤 것이든 운전자가 사용하는 자동차가 될 수 있습니다.
				- 공연 무대의 역할과 연기자
					- 로미오의 역할은 고정 되어있지만, 배우 1순위는 박보검이라도 언제든 무명 배우 가 되든 할 수 있습니다.
					- 대본에 충실하기만 하면 (역할만 잘한다면)  배우는 언제든 대체 될 수 있습니다.
			- 아무튼 역할과 구현으로 세상을 구분하면, 단순하고 유연하며 변경 할 수 있게 됩니다.
		- 자바에서 역할과 구현의 분리
			- 다형성을 이용합니다.
				- 역할은 인터페이스 로 부여하고,
				- 구현은 인터페이스를 상속받은 클래스가 됩니다.
			- 자바 언어에서 다형성
				- 오버로딩(생성자 생각), 오버라이딩(toString 생각)
		- 등장인물(객체)는 모두 만들어졌고, 그 다음은 등장인물들의 관계 입니다.
			- 혼자 있는 객체는 없어요.
			- 클라이언트 와 서버 역시 등장인물에 포함됩니다.
			- 이들은 모두 관계를 가집니다. 요청을 하고 응답을 해요. 뭔가 역할을 수행 하고 그 결과를 받아와요.
			- 이들간의 관계는 의존성(내가 쟤를 알고 있다!)을 가지고 있는데 다형성의 성질에 따라서 받는 객체는 변경 될 수 있습니다.
		- 내맘대로 결론
			- 그러니까 실제로 조립된 놈들을 그대로 보지 않고 역할과 그들을 잇는 선 으로 표현 해보면,
			- 프로그램은 각자 개성있는 모양으로 만들어진 틀과 그들이 이어진 선으로 되어있고,
			- 이 틀에 맞는 블럭들을 끼워 넣으면 관계는 이어져있는 선에 의해서 알아서 연결 되어야하고,
			- 모양만 맞으면 항상 작동 할 수 있겠네요.
			- 그러면 일단 역할과 관계는 이 프로그램 안에서는 절대 변경되지 않도록 잘 만들어야겠어요.
- 스프링과 객체 지향
	- 스프링은 다형성을 극대화 해서 이용할 수 있도록 도와줍니다.
		- 객체 내부에서 관계를 설정 하는 것이 아니라,
		- 객체 외부에서 관계를 이어줍니다 (?? ) .
		- 기존 코드를 손대지 않고도 변경할 수 있어요.

### 좋은 객체 지향 설계의 5가지 원칙 (SOLID)

- 객체 지향의 원칙 SOLID
	- 로버트 마틴이 정리한 원칙 입니다.

#### 단일 책임 원칙 (Single responsibility principle)

- 한 클래스는 하나의 책임만 가진다.
- 하나의 책임은 모호 합니다.
	- 클수도 있고, 작을 수도 있다.
	- 문맥과 상황에 따라 다르다.
- 중요한 기준은 변경 이다. 변경의 파급효과가 적어야한다.
	- UI 변경하는데 코드를 다 고쳐야 한다면 잘못 설계 한 것입니다.

#### 개방-폐쇄 원칙(Open/closed principle)

- 확장에는 열려있으나, 변경에는 닫혀 있어야한다.
	- 다형성!!  스프링!!
- 역할과 구현이 분리 되어있으면, 구현을 새로 만드는것 (확장)도 자유롭고, 새로운 구현체로 변경해도 코드를 변경할 필요가 없어집니다.
	- 스프링이 필요한 이유는 여기에 있습니다.
		- 스프링의 도움을 받지 않으면, 기존 코드의 변경이 필수적으로 수반 됩니다.
			- 예를 들어 서비스가 직접 레포지토리를 선택하게 하면, 아무리 다형성을 이용해서 새로운 레포지토리를 잘 만들어도 새로운 레포지토리로 변경할 때 서비스 코드의 변경이 필수적으로 수반됩니다.
			- 객체를 외부에서 생성하고 연관 관계를 맺어주는 별도의 조립자, 설정자가 필요합니다. 그거시 바로 스프링

#### 리스코프 치환원칙(Liskov substitution principle)

- 프로그램의 정확성을 깨트리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다.
	- 인터페이스(역할) 은 함무라비 법전 같은 것 입니다. 위에서 프로그램을 현재 상태가 아닌, 역할과 관계로 보면 틀과 선으로 볼 수 있겠다고 했었는데, 이 믿음을 깨트리면 안된다는 것 입니다.
	- 하위 클래스는 인터페이스에서 정한 규약을 다 지켜야한다.

#### 인터페이스 분리 원칙(Interface segregation principle )

- 구분되는 객체는 구분되는 인터페이스로 나뉘어져야한다(?)
- 성질이 구분되는 객체는 다른 인터페이스로 명확하게 나눠야한다.
	- 자동차 인터페이스는 운전 인터페이스와 정비 인터페이스로 분리 할 수 있습니다.
	- 이에 따라 사용자도 운전자와 정비사 인터페이스도 분리할 수 있고,
	- 이렇게 하면 정비사와 사용자 사이에는 서로 연관성이 없어지므로 영향을 주지 않고,
	- 정비와 운전 역시 서로 연관성이 없어지니 영향을 주지 않습니다.
	- 또한 구현체를 변경 하기도 쉬워지고요.
- 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.

#### 의존관계 역전 원칙(Dependency inversion principle)

- 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.
	- 클라이언트 코드는 구현체가 아닌 인터페이스만 알면 됩니다.
	- 연극 무대를 보는 관중은 로미오라는 역할과 대사에 따라 스토리를 이해하면 되지 , 로미오를 맡은 사람이 하는 애드립으로 이야기를 끌어가서 관중들을 이해 시키면 안되는 것 입니다(??????).
- 역할(인터페이스)에 의존해야한다. 구현체를 유연하게 변경할 수있으려면!
- 스프링의 도움을 받지 않으면,
	- 서비스와 레포지토리 관계에서는 레포지토리 인터페이스도 알고 있지만,
	- 구현체도 선택 하고 있습니다(구현체 의존).

#### SOLID (내맘대로) 결론:

- 그러니까, 프로그램을 만들 때는 모든 기능들을 각각의 역할 별로 완전히 나누어서 객체로 만들어야하고,
- 이 객체들은 다시 추상적인 역할과 실현물(?)로 나뉘어지는데,
- 실현물은 언제든지 바뀔 수 있도록 역할을 잘 짜야하고, 실현물은 역할에 충실하도록(?) 구성해야하고,
- 실현물이 교체 되었을때 파급효과가 적어야 하는데, 그러면 내부가 아닌 **외부에서 조립** 해야겠네요.
- 김수현 작가님이 드라마 만드실 때, 등장인물 배역이 누가 될지는 대충 고려하고 만들긴 하시겠지만, 일단 배우는 언제든 교체 가능한것이니, 배역에만 집중해서 시나리오를 모두 만들면서 내부 인물들간의 관계와 감정,
  스토리를 다 만들어놓고, 완성된 대본을 들고 카메라 감독이 드라마를 찍을 때 배역과 배우를 연결 하는 것 처럼요(?)

### 객체 지향 설계와 스프링

- 스프링은 자바의 다형성에 더해 OCP, DIP가 가능하도록 지원 합니다.
	- DI: 의존성 주입
	- DI 컨테이너 제공 : 객체들을 넣어놓고 관계를 설정해주는 것
	- 이 것들로 레고블럭 처럼 객체들을 조립할 수 있게 해줍니다.
- 스프링이 없던 시절 ..
	- OCP, DIP를 지키려고 하다보면 결국 스프링과 같은 구조가 됩니다.

# 스프링 핵심원리 이해1-예제만들기

## 2021-11-17

### 프로젝트 생성

- spring initializr
	- spring 을 사용하지 않고 순수한 자바 코드로 예제를 먼저 작성할 것이지만, 일단 스프링 부트로 프로젝트를 만듭니다.
	- 현재 안정화가 되어있는 스프링 부트 버전을 선택하고,
	- gradle project 이고,
	- java version은 11이에요.
	- group은 hello
	- artifact는 core 를 입력합니다.
	- dependecies 는 선택하지 않습니다.

### 비지니스 요구사항과 설계

- 회원
	- 회원은 가입, 조회 할 수 있다.
	- 회원 등급은 2개 등급이 있다.
	- 회원 데이터 DB는 미확정 상태이다.
- 주문과 할인 정책
	- 회원은 상품을 주문 할 수 있다.
	- 회원 등급에 따라서 할인 정책이 달라진다.
	- 회원 정책은 추후 변경 가능성이 높다.

회원 데이터베이스와 회원 정책은 아직 미확정 상태 입니다. 객체 지향적인 설계로 이 난관을 극복해봅시다.

### 회원 도메인 설계
#### 설계
- 회원
	- 회원은 가입, 조회 할 수 있다.
	- 회원 등급은 2개 등급이 있다.
	- 회원 데이터 DB는 미확정 상태이다.

- 설계
	- 회원 서비스(인터페이스)
		- 회원 가입
		- 회원 조회
	- 회원 저장소(인터페이스)
		- 구현체는 미확정
		- 구현체는 메모리 저장소 를 쓰다가 갈아끼우자.

- 참고
	- 도메인 협력관계
	- 클래스 다이어그램 (인터페이스와 구현체 관계 그림 )
	- 객체 다이어그램 (실제 사용하는 것 )

#### 첫 번째 개발

- Member 와 grade를 만들고,
- MemberRepository 와 MemberService interface 를 만들었습니다.
- 그리고 각각의 구현체 들을 만들어주었어요.
- MemberServiceImpl은 MemberRepository와 MemoryMemberRepository를 모두 의존 합니다.
- 여기서 OCP와 DIP가 모두 깨집니다.
	- 왜냐하면 앞으로 Repository를 변경하게 될텐데 그러면 ServiceImpl의 코드 수정이 수반되니까요.
	- 그리고 ServiceImpl은 interface 뿐 아니라 구현체에도 의존 하고 있으니까요.

### 주문과 할인 도메인 설계 
#### 설계
- 주문과 할인 정책
    - 회원은 상품을 주문 할 수 있다.
    - 회원 등급에 따라서 할인 정책이 달라진다.
    - 회원 정책은 추후 변경 가능성이 높다.

- 회원이 주문을 해서 주문 클라이언트가 주문 서비스에 회원 id/ 상품명 / 상품 가격을 주문 서비스에 넘기면, 
- 주문 서비스는 회원 id 를 조회 해서 등급을 뽑아오고, 할인 정책 역할한테 할인 여부를 묻습니다(할인 역할 위임)
- 그리고 할인 여부가 적용된 주문 결과를 다시 클라이언트에게 반환 합니다. 
- 그러니까 , 클라이언트는 내부에서 누가 어떻게 뭘하든 몰라도 되고, 주문 서비스만 알면 되네요. 클라이언트는 서비스랑만 데이터를 주고 받으니까요. 

#### 개발 
- Order 객체 : 회원 아이디, 상품명, 상품 가격,할인 가격 을 가지는 클래스를 만들었습니다. 정상가와 할인 가격을 계산해서 리턴해주는 메소드 도 만들었습니다. 
- OrderService는 한가지 일을 합니다. 
  - Order를 생성해서 회원 아이디로 정해진 할인된 상품 가격까지 포함된 Order 객체를 리턴해줄거에요.
  - 먼저 interface를 만들어줍니다. createOrder 를 선언해줬어요. 
  - 그리고 구현체를 만들었습니다. 
  - 구현체는 할인 정책을 직접 조회 해서 정하지 않습니다. 단일 책임의 원칙을 지켜야 하니까요.  회원 등급을 조회 하고 할인 가격을 정하는 애를 만들어서 위임 합니다. 
  - 위에서 할인 정책에게 할인에 관련된 일을 위임해버렸기 때문에 serviceImpl은 어떻게 얼마나 할인되는지 전혀 모릅니다. 
- 할인 정책 
  - 인터페이스 만들기 
      - 할인 정책은 확정되어있지 않습니다. 그래서 인터페이스로 만듭니다. 
      - 할인 정책이 하는 일은 전달된 Member를 확인해서 등급을 보고 할인율을 조회 해서 주문한 상품의 가격을 할인 해 주는 것 입니다. 
  - 구현체 만들기 
    - 고정 할인 구현체를 만들었습니다. 할인 가격을 Private 으로 선언하고, 
    - 등급을 조회 해서 VIP 면 할인 가격 1000원을 반환 해주고, VIP가 아니면 0원을 리턴 합니다. 

# 스프링 핵심원리 이해2-객체 지향 원리 적용

## 2021-11-16

# 스프링 컨테이너와 스프링 빈

## 2021-11-16

# 싱글톤 컨테이너

## 2021-11-16

# 컴포넌트 스캔

## 2021-11-16

# 의존관계 자동 주입

## 2021-11-16

# 빈 생명주기 콜백

## 2021-11-16

# 빈 스코프

## 2021-11-16

# 참고로 보면 좋은 문헌

- [스프링 역사 ](https://www.quickprogrammingtips.com/spring-boot/history-of-spring-framework-and-spring-boot.html) : 읽어보고
  블로그에 정리
- [위키피디아 : 객체지향 프로그래밍](https://ko.wikipedia.org/wiki/객체_지향_프로그래밍)
- 책
	- 객체지향의 사실과 오해
	- 토비의 스프링
	- 자바 ORM 표준 JPA 프로그래밍 