---
title: 강의 2021-11-16 스프링 핵심 원리 -기본편 
tags: [김영한, JAVA, SPRING]
categories: 강의
---

# 2021-11-16 공부 시작

## 강의 목표

- 스프링 본질에 대한 이해
	- 왜 스프링이 필요하고, 왜 만들어졌는지,
	- 어떻게 사용하는지
- 객체 지향 설계를 할 수 있게 성장하자.
- 아키텍쳐 까지 고려 하는 개발자가 되자.

## 스프링의 핵심 가치

- 스프링의 핵심은 객체 지향 프로그래밍에 있습니다.
- 자바를 배우기 시작하면서 부터 계속 객체 지향으로 시작해서 객체로 끝나네요.
- 아무튼 객체 지향원칙을 지킬 수 있도록 지원 하는 프레임워크 입니다.

# 객체 지향 설계와 스프링

## 2021-11-17

### 자바 진영의 추운 겨울과 스프링의 탄생 (위...윈터 다음 스프링 ...)

- 옛날 옛적에는 EJB 가 있었습니다.
	- Spring + JPA 합친 종합 선물 세트
		- 컨테이너 , 트렌젝션, 분산 기술 등에 강했습니다.
		- 엔티티빈 (ORM 기술 )
	- "표준" == "유행" ? = 비쌈
	- 쎄고 강하지만 ... 사실 그곳은 지옥이었고, EJB를 믿었던 개발자들은 영원히 고통받게 되었습니다.
		- 복잡하고,
		- 어렵고,
		- 느립니다.
	- 지친 개발자들은 고통을 끝내줄 뭔가를 간절하게 바라며, 순수한 자바의 세계로 돌아가자는 운동을 하였습니다.

- 그러던 어느날 .. 용자의 탄생!!
	- 로드존슨 : EJB 를 비판 하면서 단순하게 가자! 표준기술을 발표 합니다.
	- 개빈 킹 : 엔티티빈을 대체할 하이버네이트를 만듭니다.
	- JPA : 하이버네이트 를 만든 개빈 킹을 데려와서 만들었습니다.

- 스프링의 역사
	- 로드존슨이 EJB를 까면서 EJB없이도 고품질의 어플을 개발할 수 있다는 것을 보여줍니다.
	- 30000 라인의 기술을 예제코드로 보여줬는데 여기에 스프링의 핵심 기술이 들어있습니다.
	- 유겐휠러, 얀 카로프 (스프링 이름 지음 : 겨울(EJB)이 갔다! )가 프로젝트 제안 합니다.
	- (응? 우리는 처음부터 한다고요? 왜요? )
		- 개발자들의 마음을 이해하기 위해서 ....?


- 스프링의 발전
	- 1.0 : XML
	- 2.0 : XML 설정 편의 기능
	- 3.0 : 자바 코드
	- 4.0 : 자바 8 (다른가요..? )
	- 스프링 부트 출시 (2014) : 설정, 배포 어려움을 쉽게 바꿔줌
	- 5.0 & 스프링부트 2.0 : 리엑티브 프로그래밍 지원 (노드 JS 처럼 개발 )

### 스프링 이란 ?

스프링은 여러 기술의 모음 입니다.

- 스프링 ?
	- 문맥에 따라 지칭 범위가 달라집니다.
	- 스프링 DI 컨테이너
	- 스프링 프레임워크
	- 스프링 부트, 프레임워크 외 모든 것을 포함한 스프링 생태계

- 스프링 생태계
	- 필수
		- 스프링 프레임워크
			- 핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트
			- 파생 기술
		- 스프링 부트 : 스프링을 편리하게 사용할 수 있도록 지원 합니다.
			- 장점:
				- 단독 실행할 수 있는 어플리케이션 쉽게 ( 톰캣 같은 것을 따로 설정 안해도됨)
				- 쉬운 빌드 를 위한 starter 가 종속 관계 관리 해줌
				- 스프링 프레임워크 버전과 외부 라이브러리 버전들의 궁합을 정해줌
				- 모니터링 지원
				- 관례에 의한 간결한 설정 (웬만하면 디폴트..)
	- 선택
		- 스프링 데이터
		- 스프링 세션
		- 스프링 시큐리티
		- 스프링 Rest Docs
		- 스프링 배치
		- 스프링 클라우드
- 스프링을 왜 만들었는가?
	- **핵심 컨셉**
		- 자바 언어 = **객체 지향** 언어 기반의 프레임 워크 입니다.
		- 객체 지향 어플리케이션을 개발 할 수 있게 도와줍니다.
			- 좋은 객체 지향 어플리케이션이 뭐냐?
				- 객체 지향의 특징
					- 추상화 :
						- 공통의 속성, 기능을 묶어서 이름을 붙이는 것입니다.
						- 클래스를 정의 하는 것 입니다.
						- 인간, 개, 고양이를 하나로 묶는 공통적인 특성 은 포유류 입니다. 이렇게 포유류라고 붙이는 것이 추상화 입니다.

					- 캡슐화
						- 캡슐 하면 닥터 캡슐이 생각 나네요 ... ㅋㅋㅋㅋㅋㅋㅋㅋ...
						- 객체의 성질 (변수와 행위(메소드))을 함께 묶어서 외부에는 노출 되지 않도록 보호 하는 것 입니다.
					- 상속
						- 상속은 객체 간의 관계 입니다.
						- 부모 클래스의 성질을 자식 클래스가 이어 받습니다. 하지만 그 내부의 값은 변경할 수 가 있어요.
					- **다형성**
						- 다형성은 같은 이름을 붙인 것이 여러 형태 일 수 있다는 것 입니다.
						- 부여된 역할은 같아도 내부에서 동작하는 것은 서로 다르게 할 수 있는 것 입니다.
						- 롤을 할 때를 예를 들어 이해 해보았습니다.
							- 같은 팀 플레이어들의 역할은 탑, 정글, 미들, 바텀, 서포터 등으로 나눠지지요. 각자의 임무가 정해져 있습니다.
							- 그런데 플레이어가 어떤 캐릭터를 선택 하느냐에 따라 게임의 플레이가 조금씩 달라집니다.
							- 고유 스킬과 조합 해야할 아이템 등이 달라집니다. 그럼에도 역할은 바뀌지 않고 게임을 진행 합니다.
							- ~~그냥 미쳐 날뛰면 됩니다.~~
		- 그래서 객체 지향 프로그래밍이 뭔가?
			- 컴퓨터 프로그램을 객체(각자 서로 독립된 단위) 들의 모임으로 바라봅니다.
			- 이 객체들은 서로 메시지를 주고 받고 데이터를 처리합니다.
			- 객체지향 프로그래밍은 유연하고 변경이 용이 합니다.
				- 프로그램 = 레고 블럭 처럼 조립 하는 것
				- 핵심은 다형성 입니다.
		- 다형성의 실세계 비유
			- 역할과 구현으로 세상을 구분해봅시다.
				- 운전자와 자동차
					- 운전자의 역할은 자동차를 구입/선택 하고, 자동차를 작동 합니다.
					- 운전자는 자동차의 내부구조를 모르지만, 작동할 수 있고, 언제든지 자동차를 변경할 수 있습니다. **이게 진짜 중요**
					- 자동차의 역할은 운전자의 작동에 따라 이동합니다.
					- 자동차의 역할만 충실하게 따라간다면 어떤 것이든 운전자가 사용하는 자동차가 될 수 있습니다.
				- 공연 무대의 역할과 연기자
					- 로미오의 역할은 고정 되어있지만, 배우 1순위는 박보검이라도 언제든 무명 배우 가 되든 할 수 있습니다.
					- 대본에 충실하기만 하면 (역할만 잘한다면)  배우는 언제든 대체 될 수 있습니다.
			- 아무튼 역할과 구현으로 세상을 구분하면, 단순하고 유연하며 변경 할 수 있게 됩니다.
		- 자바에서 역할과 구현의 분리
			- 다형성을 이용합니다.
				- 역할은 인터페이스 로 부여하고,
				- 구현은 인터페이스를 상속받은 클래스가 됩니다.
			- 자바 언어에서 다형성
				- 오버로딩(생성자 생각), 오버라이딩(toString 생각)
		- 등장인물(객체)는 모두 만들어졌고, 그 다음은 등장인물들의 관계 입니다.
			- 혼자 있는 객체는 없어요.
			- 클라이언트 와 서버 역시 등장인물에 포함됩니다.
			- 이들은 모두 관계를 가집니다. 요청을 하고 응답을 해요. 뭔가 역할을 수행 하고 그 결과를 받아와요.
			- 이들간의 관계는 의존성(내가 쟤를 알고 있다!)을 가지고 있는데 다형성의 성질에 따라서 받는 객체는 변경 될 수 있습니다.
		- 내맘대로 결론
			- 그러니까 실제로 조립된 놈들을 그대로 보지 않고 역할과 그들을 잇는 선 으로 표현 해보면,
			- 프로그램은 각자 개성있는 모양으로 만들어진 틀과 그들이 이어진 선으로 되어있고,
			- 이 틀에 맞는 블럭들을 끼워 넣으면 관계는 이어져있는 선에 의해서 알아서 연결 되어야하고,
			- 모양만 맞으면 항상 작동 할 수 있겠네요.
			- 그러면 일단 역할과 관계는 이 프로그램 안에서는 절대 변경되지 않도록 잘 만들어야겠어요.
- 스프링과 객체 지향
	- 스프링은 다형성을 극대화 해서 이용할 수 있도록 도와줍니다.
		- 객체 내부에서 관계를 설정 하는 것이 아니라,
		- 객체 외부에서 관계를 이어줍니다 (?? ) .
		- 기존 코드를 손대지 않고도 변경할 수 있어요.

### 좋은 객체 지향 설계의 5가지 원칙 (SOLID)

- 객체 지향의 원칙 SOLID
	- 로버트 마틴이 정리한 원칙 입니다.

#### 단일 책임 원칙 (Single responsibility principle)

- 한 클래스는 하나의 책임만 가진다.
- 하나의 책임은 모호 합니다.
	- 클수도 있고, 작을 수도 있다.
	- 문맥과 상황에 따라 다르다.
- 중요한 기준은 변경 이다. 변경의 파급효과가 적어야한다.
	- UI 변경하는데 코드를 다 고쳐야 한다면 잘못 설계 한 것입니다.

#### 개방-폐쇄 원칙(Open/closed principle)

- 확장에는 열려있으나, 변경에는 닫혀 있어야한다.
	- 다형성!!  스프링!!
- 역할과 구현이 분리 되어있으면, 구현을 새로 만드는것 (확장)도 자유롭고, 새로운 구현체로 변경해도 코드를 변경할 필요가 없어집니다.
	- 스프링이 필요한 이유는 여기에 있습니다.
		- 스프링의 도움을 받지 않으면, 기존 코드의 변경이 필수적으로 수반 됩니다.
			- 예를 들어 서비스가 직접 레포지토리를 선택하게 하면, 아무리 다형성을 이용해서 새로운 레포지토리를 잘 만들어도 새로운 레포지토리로 변경할 때 서비스 코드의 변경이 필수적으로 수반됩니다.
			- 객체를 외부에서 생성하고 연관 관계를 맺어주는 별도의 조립자, 설정자가 필요합니다. 그거시 바로 스프링

#### 리스코프 치환원칙(Liskov substitution principle)

- 프로그램의 정확성을 깨트리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다.
	- 인터페이스(역할) 은 함무라비 법전 같은 것 입니다. 위에서 프로그램을 현재 상태가 아닌, 역할과 관계로 보면 틀과 선으로 볼 수 있겠다고 했었는데, 이 믿음을 깨트리면 안된다는 것 입니다.
	- 하위 클래스는 인터페이스에서 정한 규약을 다 지켜야한다.

#### 인터페이스 분리 원칙(Interface segregation principle )

- 구분되는 객체는 구분되는 인터페이스로 나뉘어져야한다(?)
- 성질이 구분되는 객체는 다른 인터페이스로 명확하게 나눠야한다.
	- 자동차 인터페이스는 운전 인터페이스와 정비 인터페이스로 분리 할 수 있습니다.
	- 이에 따라 사용자도 운전자와 정비사 인터페이스도 분리할 수 있고,
	- 이렇게 하면 정비사와 사용자 사이에는 서로 연관성이 없어지므로 영향을 주지 않고,
	- 정비와 운전 역시 서로 연관성이 없어지니 영향을 주지 않습니다.
	- 또한 구현체를 변경 하기도 쉬워지고요.
- 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.

#### 의존관계 역전 원칙(Dependency inversion principle)

- 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.
	- 클라이언트 코드는 구현체가 아닌 인터페이스만 알면 됩니다.
	- 연극 무대를 보는 관중은 로미오라는 역할과 대사에 따라 스토리를 이해하면 되지 , 로미오를 맡은 사람이 하는 애드립으로 이야기를 끌어가서 관중들을 이해 시키면 안되는 것 입니다(??????).
- 역할(인터페이스)에 의존해야한다. 구현체를 유연하게 변경할 수있으려면!
- 스프링의 도움을 받지 않으면,
	- 서비스와 레포지토리 관계에서는 레포지토리 인터페이스도 알고 있지만,
	- 구현체도 선택 하고 있습니다(구현체 의존).

#### SOLID (내맘대로) 결론:

- 그러니까, 프로그램을 만들 때는 모든 기능들을 각각의 역할 별로 완전히 나누어서 객체로 만들어야하고,
- 이 객체들은 다시 추상적인 역할과 실현물(?)로 나뉘어지는데,
- 실현물은 언제든지 바뀔 수 있도록 역할을 잘 짜야하고, 실현물은 역할에 충실하도록(?) 구성해야하고,
- 실현물이 교체 되었을때 파급효과가 적어야 하는데, 그러면 내부가 아닌 **외부에서 조립** 해야겠네요.
- 김수현 작가님이 드라마 만드실 때, 등장인물 배역이 누가 될지는 대충 고려하고 만들긴 하시겠지만, 일단 배우는 언제든 교체 가능한것이니, 배역에만 집중해서 시나리오를 모두 만들면서 내부 인물들간의 관계와 감정,
  스토리를 다 만들어놓고, 완성된 대본을 들고 카메라 감독이 드라마를 찍을 때 배역과 배우를 연결 하는 것 처럼요(?)

### 객체 지향 설계와 스프링

- 스프링은 자바의 다형성에 더해 OCP, DIP가 가능하도록 지원 합니다.
	- DI: 의존성 주입
	- DI 컨테이너 제공 : 객체들을 넣어놓고 관계를 설정해주는 것
	- 이 것들로 레고블럭 처럼 객체들을 조립할 수 있게 해줍니다.
- 스프링이 없던 시절 ..
	- OCP, DIP를 지키려고 하다보면 결국 스프링과 같은 구조가 됩니다.

# 스프링 핵심원리 이해1-예제만들기

## 2021-11-17

### 프로젝트 생성

- spring initializr
	- spring 을 사용하지 않고 순수한 자바 코드로 예제를 먼저 작성할 것이지만, 일단 스프링 부트로 프로젝트를 만듭니다.
	- 현재 안정화가 되어있는 스프링 부트 버전을 선택하고,
	- gradle project 이고,
	- java version은 11이에요.
	- group은 hello
	- artifact는 core 를 입력합니다.
	- dependecies 는 선택하지 않습니다.

### 비지니스 요구사항과 설계

- 회원
	- 회원은 가입, 조회 할 수 있다.
	- 회원 등급은 2개 등급이 있다.
	- 회원 데이터 DB는 미확정 상태이다.
- 주문과 할인 정책
	- 회원은 상품을 주문 할 수 있다.
	- 회원 등급에 따라서 할인 정책이 달라진다.
	- 회원 정책은 추후 변경 가능성이 높다.

회원 데이터베이스와 회원 정책은 아직 미확정 상태 입니다. 객체 지향적인 설계로 이 난관을 극복해봅시다.

### 회원 도메인 설계

#### 설계

- 회원
	- 회원은 가입, 조회 할 수 있다.
	- 회원 등급은 2개 등급이 있다.
	- 회원 데이터 DB는 미확정 상태이다.

- 설계
	- 회원 서비스(인터페이스)
		- 회원 가입
		- 회원 조회
	- 회원 저장소(인터페이스)
		- 구현체는 미확정
		- 구현체는 메모리 저장소 를 쓰다가 갈아끼우자.

- 참고
	- 도메인 협력관계
	- 클래스 다이어그램 (인터페이스와 구현체 관계 그림 )
	- 객체 다이어그램 (실제 사용하는 것 )

#### 첫 번째 개발

- Member 와 grade를 만들고,
- MemberRepository 와 MemberService interface 를 만들었습니다.
- 그리고 각각의 구현체 들을 만들어주었어요.
- MemberServiceImpl은 MemberRepository와 MemoryMemberRepository를 모두 의존 합니다.
- 여기서 OCP와 DIP가 모두 깨집니다.
	- 왜냐하면 앞으로 Repository를 변경하게 될텐데 그러면 ServiceImpl의 코드 수정이 수반되니까요.
	- 그리고 ServiceImpl은 interface 뿐 아니라 구현체에도 의존 하고 있으니까요.

### 주문과 할인 도메인 설계

#### 설계

- 주문과 할인 정책
	- 회원은 상품을 주문 할 수 있다.
	- 회원 등급에 따라서 할인 정책이 달라진다.
	- 회원 정책은 추후 변경 가능성이 높다.

- 회원이 주문을 해서 주문 클라이언트가 주문 서비스에 회원 id/ 상품명 / 상품 가격을 주문 서비스에 넘기면,
- 주문 서비스는 회원 id 를 조회 해서 등급을 뽑아오고, 할인 정책 역할한테 할인 여부를 묻습니다(할인 역할 위임)
- 그리고 할인 여부가 적용된 주문 결과를 다시 클라이언트에게 반환 합니다.
- 그러니까 , 클라이언트는 내부에서 누가 어떻게 뭘하든 몰라도 되고, 주문 서비스만 알면 되네요. 클라이언트는 서비스랑만 데이터를 주고 받으니까요.

#### 개발

- Order 객체 : 회원 아이디, 상품명, 상품 가격,할인 가격 을 가지는 클래스를 만들었습니다. 정상가와 할인 가격을 계산해서 리턴해주는 메소드 도 만들었습니다.
- OrderService는 한가지 일을 합니다.
	- Order를 생성해서 회원 아이디로 정해진 할인된 상품 가격까지 포함된 Order 객체를 리턴해줄거에요.
	- 먼저 interface를 만들어줍니다. createOrder 를 선언해줬어요.
	- 그리고 구현체를 만들었습니다.
	- 구현체는 할인 정책을 직접 조회 해서 정하지 않습니다. 단일 책임의 원칙을 지켜야 하니까요. 회원 등급을 조회 하고 할인 가격을 정하는 애를 만들어서 위임 합니다.
	- 위에서 할인 정책에게 할인에 관련된 일을 위임해버렸기 때문에 serviceImpl은 어떻게 얼마나 할인되는지 전혀 모릅니다.
- 할인 정책
	- 인터페이스 만들기
		- 할인 정책은 확정되어있지 않습니다. 그래서 인터페이스로 만듭니다.
		- 할인 정책이 하는 일은 전달된 Member를 확인해서 등급을 보고 할인율을 조회 해서 주문한 상품의 가격을 할인 해 주는 것 입니다.
	- 구현체 만들기
		- 고정 할인 구현체를 만들었습니다. 할인 가격을 Private 으로 선언하고,
		- 등급을 조회 해서 VIP 면 할인 가격 1000원을 반환 해주고, VIP가 아니면 0원을 리턴 합니다.

# 스프링 핵심원리 이해2-객체 지향 원리 적용

## 2021-11-18

### 새로운 할인 정책 개발

#### 악덕 기획자의 등장

- 서비스 오픈 직전에 할인 정책 변경을 요구
	- 정률 할인 정책으로 변경
	- 애자일 소프트웨어 개발 선언
		- 계획 ㄴㄴ 변화 ㅇㅇ
	- 객체 지향 원칙으로 가보자고!

#### 개발

- RateDiscountPolicy 를 만듭시다.
	- 별거 없이 Grade가 VIP 인지 묻고 , 맞다면 상품가격의 10프로를 리턴해줍니다.
- 테스트 (메소드 명 위에 마우스 대고 shift + command + T ) 클래스 를 만들었어요.
	- @DisplayName(""")은 테스트에 제목을 붙여줍니다.
	- VIP 면 할인 정책이 적용되는 지 뿐만 아니라,
	- VIP가 아니면 할인정책이 적용되지 않는지 까지 테스트를 합니다.
	- 돈이 관련된 문제는 테스트를 아주 잘 해줘야하는데, 우리는 할인 정책만 따로 객체로 만들어두었기 때문에 편하게 테스트 할 수 있어요 ...

### 새로운 할인 정책 적용

#### 문제점

할인 정책을 바꾸려면 OrderServiceImpl 의 코드를 고쳐야합니다.

- OCP와 DIP 원칙이 깨졌습니다.
	- OrderServiceImpl 는 구현체를 의존합니다. (DIP 위반)
	- 그래서 결국 DiscountPolicy 를 바꾸면 구현체를 바꿔줘야하니, OCP 도 위반하게 됩니다.

#### 문제 해결 방법

- 인터페이스에만 의존하게 만들자! (NullPointException...)

### 관심사의 분리

#### 의미

- 공연의 배역을 맡을 배우는 **공연기획자**가 정합니다.
- 이전에 우리가 작성한 코드는 배우가 상대배우를 선택한 것과 같습니다.
- 배우(구현체)는 자신의 역할 수행에만 집중하고, 역할을 수행할 구현체를 지정하는 것은 기획자가 하도록 책임이 구분 되어야합니다.
- 이렇게 분리하는 것을 관심사의 분리라고 합니다.

#### AppConfig == 공연 기획자

- 프로그램의 각각 역할을 수행할 구현체들을 지정(생성)하고 그들의 관계를 연결할 책임을 지는 설정 클래스 입니다.
- 이제 얘가 구현 객체를 생성 할거에요.
- 생성한 객체 인스턴스의 참조를 생성자를 통해서 주입해줍니다.
	- AppConfig를 만들면서, MemberServiceImpl과 OrderServiceImpl의 Repository와 Policy 구현체를 삭제하고, 생성자를 만들어서 구현체를 끼우게 (?)해줬어요.
	- 이제 AppConfig 에서 각 객체를 소환할때는 우리가 원하는 구현객체를 끼워서 MemberServiceImpl과 OrderServiceImpl 얘들을 만들어줄거에요.

#### AppConfig의 영향력

- 이제 각 클래스들은 더이상 구현체에 의존하지 않습니다. 인터페이스만 알고 있습니다. (DIP 원칙을 지킵니다.)
- Config에서 주입 해주는 구현체 들에 의해서 역할을 수행할 객체들이 정해지고 각자의 역할을 수행합니다.

#### 코드 수정

- 테스트 코드(클라이언트)를 만들면서 서비스 구현체를 직접 만들고 얘가 열일 하게 했었는데,
- 이제는 AppConfig를 만들어서 얘가 일하게 바꿨어요.
- 이제 클라이언트도 서비스 구현체가 뭔지 몰라도 되요.

### AppConfig 리팩터링

- 문제
    - 중복
    - 역할에 따른 구현이 한눈에 보이지 않습니다.
    - 현재 코드
    - 
      ```java
      public class AppConfig {
      public MemberService memberService(){

        return new MemberServiceImpl(new MemoryMemberRepository());
      }

      public OrderService orderService(){
      return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy());
      }
      }
      ```
      - 리팩터링
          - new MemoryMemberRepository() 의 중복을 제거 해줍니다.
          - 역할과 구현이 한눈에 들어오므로, 전체 구성 파악을 빠르게 할 수 있게 합니다.
      - 변경된 코드

      ```java
      public class AppConfig {
      public MemberService memberService() {

        return new MemberServiceImpl(memberRepository());
      }

      private MemberRepository memberRepository() {
      return new MemoryMemberRepository();
      }

      public OrderService orderService() {
      return new OrderServiceImpl(memberRepository(), discountPolicy());
      }

      public DiscountPolicy discountPolicy() {
      return new FixDiscountPolicy();
      }
      }
      ```

### 새로운 구조와 할인 정책 적용

- 정액 할인 정책을 정률 할인 정책으로 변경 해봅시다.
- AppConfig 의 등장으로 사용영역과 구성영역이 분리 되었기 때문에, 우리는 AppConfig 만 수정 하면 됩니다.
- 이렇게 기획자의 존재 만으로 이제 클라이언트는 구현체에 의존하지 않게 되었으며, 구현체가 변경되더라도 코드를 변경하지 않아도 되네요.

### 전체 흐름 정리

- 새로운 할인 정책 개발
	- 다형성을 이용해서 코드 변경하지 않고 새로운 객체를 개발 했습니다.
- 새로운 할인정책의 적용
	- 여기서 DIP위반, OCP 위반이 있었습니다.
- 문제점의 해결 : 관심사의 분리 (feat. 기획자의 등장)
	- 이전까지는 객체의 책임 범위가 너무 넓었습니다. 자신의 역할 수행 뿐 아니라, 혐력하는 객체 까지 지정하는 책임을 지고 있었어요.
	- 협력관계를 정해주는 객체(기획자,AppConfig)를 만들어서 이 책임을 덜어줬습니다. 얘가 이제 구현 객체를 생성하고 객체 간의 연결을 담당합니다.
- AppConfig의 리팩터링
	- 중복 코드를 삭제 하고, 구성을 모두 파악할 수 있도록 코드를 수정 해주었습니다.
	- 역할과 구현을 명확히 분리 했고, 역할을 잘 드러나게 했습니다.
- 다시 새로운 할인 정책의 적용
	- AppConfig 의 등장으로 구성영역과 사용영역이 분리 되면서 내부 중요 로직 코드는 변경할 필요 없이 정책을 변경할 수 있었습니다.
- 여기서 드는 고민 :
	- 그러면 프로그램을 개발 하기에 앞서서 설계할 때 어떻게 하면 객체를 잘 설계할 수 있을까?
	- 지금은 눈앞이 깜깜합니다.

### 좋은 객체 지향 설계의 5가지 원칙의 적용

- SRP
	- 관심사 분리를 통해 객체의 책임 범위를 좁혔습니다.
- DIP
	- 생성자를 이용한 의존성 주입 + AppConfig의 도움으로 클라이언트는 이제 구현체를 몰라도 됩니다.
- OCP
	- 다형성 + DIP 원칙을 지키면서 사용영역에서 OCP 역시 지킬 수 있었습니다.

### IoC, DI, 그리고 컨테이너

#### 제어의 역전 Inversion of Control(IoC)

- 개발자가 또는 객체가 다른 객체를 생성하고 호출 하는 것이 아니라, 프레임 워크 등이 객체를 생성하고, 호출 하게 하는 등 제어권을 어떤 주체에게 넘겨주는 것 입니다.
- AppConfig 의 등장으로 클라이언트 코드가 변경 된 것을 한번 떠올려보아요.
	- AppConfig 가 구현체를 직접 생성하고, 주입 하게 변경 되었어요.
	- 그래서 이제 클라이언트도, ServiceImpl도 구현체를 직접 지정해서 생성하지 않습니다.
	- AppConfig 말고는 어떤 구현체가 들어가서 작업을 하게 되는지 몰라요. 누군지 모르니까 내부에서 어떤 작업을 하는지도 모릅니다.
	- 그냥 요청을 하고 돌려받은 결과물을 가지고 자신의 작업만 하게 됩니다.
	- 이렇게 자신이 시키는데도 (?) 직접 제어하지 못하고 외부에 제어권을 넘기는 것을 제어의 역전이라고 합니다.
- 프레임워크와 라이브러리 의 구분
	- 작성한 코드의 제어권을 넘겨 주면 프레임워크, 아니면 라이브러리 입니다.

#### 의존관계 주입

- 의존관계
	- 정적인 클래스 의존관계
		- 클래스의 import 코드만 보고 바로 판단할 수 있습니다 (클래스 다이어그램으로 볼 수 있습니다.).
		- 인터페이스와 이를 상속하고 있는 구현체들 + 각 인터페이스 간의 협력 관계를 보여주는 것.
		- 실제 어떤 구현체가 일을 하는지는 알 수가 없습니다.
	- 동적인 객체 의존관계
		- 애플리케이션 실행 시점에 생성된 객체 인스턴스의 참조가 연결된 의존관계 입니다.
		- 실제 어플리케이션에서 일하는 구현체 들간의 관계를 보여줍니다.
- 의존관계 주입
	- 정적인 의존관계를 손대지 않고(코드를 변경하지 않고), 동적인 객체 의존관계를 쉽게 변경할 수 있습니다.

#### IoC 컨테이너, DI 컨테이너

- AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것을 말합니다.
- DI 컨테이너는 의존관계의 주입에 초점을 맞춘 컨테이너를 말합니다.
- 동의어 (?) : 어셈블러(조립자) , 오브젝트 팩토리 (객체 공장?)

### 스프링으로 전환하기

- AppConfig 변경하기
	- 우리는 이제 org.springframework.context.annotation 을 이용해서 Spring이 Config 가 했던 일을 관리 해줄 수 있도록 할거에요.
		- @Configuration :
			- 이 클래스가 설정을 위한 것 임을 알려주고, 안의 메소드들을 bean 등록 할 것 임을 알려줍니다.
			- 얘를 들어가보면 @Component를 어노테이션 하고 있어요. 그래서 컴포넌트 스캔이 되요.
			- @Target(ElementType.TYPE)
			  @Retention(RetentionPolicy.RUNTIME)
			  @Documented : JavaDoc 생성시 Annotation에 대한 정보도 함께 생성한대요. @Component
		- @Bean : 어노테이션이 달린 메소드의 리턴 객체를 이제 스프링 컨테이너가 관리 하게 됩니다.
			- 이렇게 컨테이너에 등록된 객체를 스프링 빈 이라고 합니다.
			- 이렇게 등록 된 빈은 applicationContext.getBean 으로 찾아올 수 있어요.

- 스프링 컨테이너 사용하기
	- applicationContext 를 스프링 컨테이너라고 합니다.
	- 스프링 컨테이너를 만들때 , AppConfig가 이 컨테이너의 주인(?설계도? )이 되게 했어요.
	- 그리고 이 컨테이너에서 만들어진 객체들(AppConfig에서 만든 메소드에서 리턴하는 객체) 을 필요에 따라서 찾아올거에요(applicationContext.getBean).
	- 코드 :
	```java
     applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
     MemberService memberService = applicationContext.getBean("memberService", MemberService.class);
     OrderService orderService = applicationContext.getBean("orderService", OrderService.class);
	 ```
- 스프링 컨테이너를 사용했을때 장점?!
	- 범용의 프레임이 생긴 것
	- 이제 부터 배우면서 계속 알아봅시다!

# 스프링 컨테이너와 스프링 빈

## 2021-11-18

### 스프링 컨테이너 생성

####applicationContext
- applicationContext 를 스프링 컨테이너라고 합니다.
- applicationContext는 인터페이스 입니다.
    - 우리가 이전에 AnnotationConfigApplicationContext 객체를 만들었던 것은 이 인터페이스의 구현체 입니다. 
- 생성 방법
    - XML
        - 요즘엔 거의 사용하지 않습니다.
    - 어노테이션
- BeanFactory 와의 관계 : 

#### 컨테이너 생성 과정 
##### 컨테이너의 생성 
1. new AnnotationConfigApplicationContext(AppConfig.class)로 config 정보를 주면서 컨테이너를 생성하면,
2. 스프링컨테이너가 만들어집니다.
   1. 스프링컨테이너 안에는 빈 저장소가 있습니다. 
   2. 여기에는 빈 이름과 객체가 저장됩니다. 
3. 컨테이너가 AppConfig.class를 보고 객체를 생성해야겠다고 인지합니다. 

##### 빈의 생성 
4. 그리고 AppConfig.class안에 @Bean이 붙은 메소드를 모두 호출 합니다. 
5. 호출 한 메소드 명을 빈 이름 으로, 리턴 객체를 빈 객체로 저장소에 저장합니다. 
   1. 빈 이름은 지정할 순 있습니다. 
   2. 빈 이름은 항상 중복되면 안됩니다. 
   3. 빈을 덮어버리거나 오류가 발생하기 때문입니다.

##### 의존관계의 생성
6. 의존관계 설정 
   1. 설정정보를 참조해서 의존관계를 주입 합니다. (사실 Config 설정에 따라  메소드의 생성자를 호출 하면서 의존관계가 만들어집니다.)
   2. 자바 코드를 호출 하는 것과 차이가 있습니다(싱글톤 컨테이너 부분에서 설명)
### 컨테이너에 등록된 모든 빈 조회 
- getBeanDefinitionNames 
  - org.springframework.context.* 은 스프링 내부에서 사용하는 빈 
- 내부에 있는 것을 빼고 싶다면 : beanDefinition.getRole() 로 걸러줍니다! 

### 스프링 빈 조회 - 기본
- getBean(빈이름, 타입 )  or getBean(빈이름)
- 구현체로도 조회 할 수 있습니다. (ac.getBean("memberService", MemberServiceImpl.class);)
- 제대로 에러가 나는지도 테스트를 해야합니다. 
  - junit 의 assertThrows() 사용해요. 
    - ac.getBean("XXXX", MemberService.class) 를 조회 하면 NoSuchBeanDefinitionException이 나오는지 확인해봅니다. 
### 스프링 빈 조회 - 동일한 타입이 둘 이상
    
같은 타입의 스프링 빈이 둘 이상이면 오류가 발생합니다(NoUniqueBeanDefinitionException). 
이런 경우에는 빈 이름을 지정해야합니다. 
- 특정 타입을 모두 조회 하려면 ac.getBeansOfType(MemberRepository.class) 을 호출 합니다. 
- 이 메서드로 리턴되는 타입은 Map<String, MemberRepository>이네요. 
- 이걸 for문으로 하나씩 불러서 프린트를 해줍시다. 
- 그리고 리턴된 Map의 사이즈가 우리가 등록한 bean 의 수와 맞는지 확인 해봅니다. 

### 스프링 빈 조회 - 상속 관계
- 빈 조회 시 상속관계로 되어있다면? 
  - 기본 대원칙 : 부모 를 조회 하면 자식도 모두 조회 됩니다. ( object type 을 조회 하면 모든 빈이 다나오겠...? )
- 그래서, 부모 타입으로 조회시, 자식이 둘 이상 있으면 중복 오류가 발생 합니다.

### Bean 조회 하기를 배운 이유 

순수 자바로 만든 클래스를 스프링 컨테이너에 넣어야할 상황이 오기도하고, 
상속 관계가 있는 경우 어디까지 끌려나오는지를 알아두면, 나중에 스프링이 의존관계 자동 주입을 해주는 부분을 이해 하기 수월해지기 때문입니다. 

### BeanFactory와 ApplicationContext

- BeanFactory(interface)
  - 스프링 빈을 관리, 조회 하는 역할을 합니다. 
  - getBean 을 제공합니다. 
- ApplicationContext(BeanFactory를 상속)
  - BeanFactory와 차이 
    - bean 관리 외 부가 기능 
      - 메세지 소스
        - 국제화 기능 : 언어권에 따라 다른 언어를 출력해줍니다.
      - 환경변수 
        - 환경에는 크게 3가지가 있습니다(로컬, 개발, 운영 + 스테이지)
        - 환경별로 환경변수를 다르게 조정 해줍니다. 
        
      - 애플리케이션 이벤트  : 이벤트 발행, 구독 하는 모델을 편리하게 지원
      - 편리한 리소스 조회  : 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회할 수 있습니다.

### 다양한 설정 형식 지원 - 자바 코드, XML 
- 스프링은 다양한 형식의 설정 정보를 받아들일 수 있습니다. 
  - java (AnnotationConfigApplicationContext)
  - XML (GenericXmlApplicationContext)
  - XXX - > 임의의 뭔가로 인식 시킬 수 있습니다. 
- XML 설정 
  - 스프링 부트 점유율이 높아지면서 많이 사용하지는 않습니다. 
  - 컴파일 없이 설정할 수 있다는 장점이 있습니다. 
  - java code 로 작성 하고 annotation 으로 올려서 썼던 것이랑 거의 똑같습니다. 
    - bean id 에 해당 빈의 이름(java code method) 를 적고, class는 bean으로 등록되는(java code 에서 리턴되는 구현체 타입)의 클래스를 적으면 됩니다. 
    - java code 에서 생성자 주입을 했던 것은 XML 에서는 contructor-arg 에서 등록(?)해주면 됩니다. 
  
### 스프링 빈 설정 메타 정보 - BeanDefinition
- 다양한 형식의 설정 을 스프링이 지원할 수 있는 이유 
  - 이유의 핵심은 BeanDefinition 의 추상화 입니다.
  - 역할과 구현을 잘 나눠서 그런 것인데, 스프링 컨테이너는 역할 인 BeanDefinition에만 의존합니다. 그래서 실제로 설정 정보를 처리하는 구현체는 몰라도 됩니다. 
  - BeanDefinition은 bean 메타정보 라고 합니다. 
    - bean 을 어떻게든(어노테이션이든, XML이든) 등록 하면 각각 메타 정보가 생성됩니다. 
        - 각각 BeanDefinition 구현체 들은 인풋 형식에 맞는 Reader로 메타 정보를 담아 둡니다. 
  - BeanDefinition을 직접 생성 해서 스프링 컨테이너에 등록할 수 도 있습니다.(실무 ㄴㄴ)
# 싱글톤 컨테이너

## 2021-11-19
### 웹 애플리케이션과 싱글톤
- 싱글톤 컨테이너는 싱글톤 패턴과 관계 있는 개념 입니다. 
- 스프링은 기업용 온라인 서비스 기술을 지원 하기위한 것 입니다
  - (대량의 동시 처리?)
    - 우리가 만들었던 AppConfig(노 스프링)는 각 클라이언트 의 요청 하나 하나 마다 새로운 객체를 생성 해서 반환 해줍니다. 
      - 문제: 요청 이 무한대 == 객체 무한대 생성 == 비효율
    - 해당 객체가 하나만 생성되고 공유 하게 하면 위와 같은 문제를 해결 할 수 있습니다. 그거시 바로 싱글톤 패턴입니다. 

### 싱글톤 패턴
- 클래스 인스턴스 가 딱 하나만 생성되는 것을 보장하는 디자인 패턴 입니다. 
- 직접 만들어봅시다.(SingletonService)
  - private static final SingletonService instance = new SingletonService :  클래스 내부에서 SingletonService 객체를 만들어둡시다. 만들어진 요놈만 꺼내서 쓸  수 있게 할거에요.
    - private 이므로 이 클래스 외부에서는 절대 바로 접근할 수 없어요. 
    - static 이 붙었으니까, SingletonService 를 처음 호출 하면 가장 처음에 메모리영역에 생성 되고, 프로그램 종료시까지 같은놈을 공유하게 될거에요. 
    -그리고 final이 붙었으니 값을 수정하지 못합니다. 
    - 이 instance 는 SingletonService 자기자식을 객체생성 하고, 이 주소 값을 가지고 있네용.
  - private으로 되있으니,  호출은 getInstance ()를 통해서 할 수있도록 해줍니다. 
  - 그리고 이제 생성자도 private 으로 막아서 SingletonService 를 별도로 생성하지 못하게 막아줍시다.
#### 싱글톤 패턴의 문제 
- 싱글톤 패턴 적용을 위해서 코드를 많이 작성 해야합니다. 
- 의존관계의 문제가 있습니다. 클라이언트가 구현체를 알고 있어야합니다. 
- 위의 이유 때문에 개방폐쇄원칙도 위반될 가능성이 높습니다. 
- 테스트 하기 어렵습니다. 
- 내부 속성을 변경 하기 어렵습니다. 
- 유연성이 떨어집니다. 

#### 스프링 프레임워크의 힘 
- 스프링은 빈을 싱글톤으로 사용하게 해주면서도 싱글톤 패턴의 문제점을 모두 해결해줍니다. 
- 훌륭하네요.

### 싱글톤 컨테이너
- 스프링 컨테이너는 등록된 빈 객체를 싱글톤으로 관리 해줍니다. 
  - 스프링 컨테이너가 싱글톤 레지스토리 기능을 보유하고 있어요. 그래서 싱글톤 컨테이너 역할을 할 수 있습니다. 
    - 싱글톤 레지스토리 : 싱글톤 객체를 생성, 관리하는 기능  
    - 싱글톤 컨테이너: 싱글톤 패턴을 적용하지 않아도 객체 인스턴스를 싱글톤으로 관리 해주는 컨테이너를 말합니다.
- 스프링 컨테이너의 싱글톤 레지스토리 기능 원리(?): 
  - 빈 등록을 하게 되면 컨테이너가 스프링 빈 저장소에 빈 이름과 관리되는 빈 객체를 저장해줍니다. 
  - 그리고 이제 빈을 조회할 때 마다 위에서 등록된 객체를 꺼내서 (?) 쓰게 할 것이에요. 이거시 바로 싱글톤...! 


### 싱글톤 방식의 주의점 
- 객체 인스턴스를 하나만 생성해서 공유 하기 때문에 주의해야한다.
  - 객체를 공유 하기 때문에 다른 클라이언트가 공유되는 필드의 값을 변경하게 되면, 다른 클라이언트의 의도와 다른 결과를 리턴할 수 있기 때문입니다. 
- 그래서 싱글톤 객체는 무상태(stateless )로 설계 해야합니다. 
  - 무상태? 너모.. 와닿지 않는 단어 
  - 특정 클라이언트에 의존적인 필드가 있으면 안됩니다. 
  - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안됩니다. 
  - 가급적 읽기만 가능해야합니다. 
  - 필드에서 뭔가를 꺼내오는대신, 공유가 되지 않는 메소드 안의 지역 변수, 파라미터, ThreadLocal 등을 사용해야합니다. 
    - ThreadLocal? 
      - Thread 단위로 로컬 변수를 할당하는 기능 입니다. 
        - Thread? : 실행중인 하나의 어플리케이션을 프로세스 라고 합니다. 한 프로세스 안에서 동작하는 여러 실행흐름을 Thread라고 합니다(전에 자바 시간에 자바는 멀티 스레드를 지원하고, 자바 어플리케이션은 메인 스레드가 메인 메소드를 시작하면서 실행한다고 배웠던 그것 ! ) 
      
# 컴포넌트 스캔

## 2021-11-16

# 의존관계 자동 주입

## 2021-11-16

# 빈 생명주기 콜백

## 2021-11-16

# 빈 스코프

## 2021-11-16

# 참고로 보면 좋은 문헌

- [스프링 역사 ](https://www.quickprogrammingtips.com/spring-boot/history-of-spring-framework-and-spring-boot.html) : 읽어보고
  블로그에 정리
- [위키피디아 : 객체지향 프로그래밍](https://ko.wikipedia.org/wiki/객체_지향_프로그래밍)
- 책
	- 객체지향의 사실과 오해
	- 토비의 스프링
	- 자바 ORM 표준 JPA 프로그래밍 