---
title: TIL 2021-09-29 JAVA class에 대해 배워보았습니다. 
tags: [TIL, JAVA]
categories: TIL
---
## 👀 오늘 배운 것 
오늘도 java 객체에 대해 배웠습니다.

- 먼저 package 개념에 대해 더욱 자세하게 배웠는데, 패키지는 객체를 하나의 단위로 묶은 집합체로,관련된 객체들을 묶어놓은 디렉토리라고 볼 수 있습니다.
    - 인텔리제이나 이클립스에서 간단하게 패키지를 생성하고 그 아래에 자바파일을 생성하면 자동으로 package X;가 생성되어있는데, 패키지 내에 또 다시 패키지를 설정할 수 있어서 이럴 때는 디렉토리경로와 같이 .을 사용해서 root폴더내 패키지 부터 현재 자바 파일이 들어있는 패키지가 표현됩니다.
    - 터미널에서도 javac -d 옵션을 사용해서 패키지폴더를 자동으로 만들게 하고 컴파일 할 수 있습니다.

- 접근 제한자를 어떻게 설정하는지에 따라 다르지만, 다른 패키지에 있는 객체를 사용하기 위해 import를 사용합니다.이때 주의 할 점은 "."으로 root부터 해당 패키지 까지 경로를 적어주어야 하는데, 해당 객체를 포함하고 있는 패키지까지 모두 적어주어야하며, 해당 패키지 내 모든 파일을 import할 수 있도록 "*"을 사용할수는 있지만 메모리 관리에 신경 써야한다는 것입니다. (경로,메모리 관리)

- 저번 시간에 클래스에 대해 배우면서 접근 제한자에 대해 배웠었는데,오늘은 접근 제한자와 제한자 쓰는 이유를 배웠습니다. 객체를 다른 파일에서 불러다 쓸 때, 설계시 의도치 않은 사용을 제한 하기 위해서 private (캡슐화)을 이용해 제한 한다고 하는데, 오늘 배운 예제에서는 day를 객체에 저장하는데 잘못된 날짜가 등록 되는 것을 막기 위해 private으로 직접 day를 건들지 못하게 하는 대신 set을 사용하는 방법에 대해 배웠습니다. 
    - get (getter 메소드)
    - set (setter 메소드)

```java
//멤버변수 day 값을 수정하는 기능:
public void setDay(int day) {
    if (day>32){
        System.out.println("잘못된 값입니다.");
    }else{
        this.day = day;
    }
```

- 메소드를 호출하면 일어나는일에 대해서 배웠습니다. 
    - 메모리 영역에서 일어나는 일 
        - main() 호출 하면 
        - stack 메모리에 main 영역으로 구분됨
        - 명령문 순서대로 영역에 메모리 공간을 만듬!
        - 메소드 호출을 만나면!!!!
            - 객체를 찾아서 stack에 새로운 메소드 영역이 생김 -> 메소드 실행 -> 메소드 영역 삭제 되고 main 영역으로 돌아감 
        - main 영역 끝나면 모든 메모리 영역 삭제됨 
    - (멤버 변수) 메인 메소드에서 클래스를 호출 하면, 클래스 내 멤버 변수는 자동 초기화됩니다. 기본 데이터와 참조 데이터 각각 정해진 값으로 초기화 되게 됩니다. 아래 코드에서 d.year의 경우에는 아무 값을 저장하지 않아도 0이 출력되지만, 지역변수인 age는 에러가 납니다. 
    ```java
    public class MyDateTest {
        public static void main(String[] args) {
            MyDate d = new MyDate();
            //System.out.println(d.year);
            //자동 초기화 되서 0이 출력되지롱
            /*int age;
            System.out.println(age);-> 에러가 나지롱 */
    ```
    - (메소드) 메소드도 제어자를 설정할 수있고,변수의 타입을 정하는 것 처럼 리턴 값 타입을 정해야 하는데,이 때 정한 타입과 실제 return한 타입이 같아야 합니다. 
        - return의미는 메소드 실행 종료라는 의미로, void로 리턴하지 않도록 정한 경우에도 써도 상관은 없습니다. 

- 자동차를 만들어보자 🚌 부릉부릉 
    - 어제 아이언맨 수트에 이어서 자동차를 만들었습니다 ㅋㅋ.타고 싶다 BMW.....
    - 자동차를 만들면서 this 키워드에 대해 배웠습니다. this는 메소드를 호출하면 생성되는 현재 실행중인 인스턴스의 주소 값을 저장한 변수입니다. 메소드 실행시 자동으로 생성되는데, this.변수 를 사용해서 heap메모리에 올라와있는 클래스 내 변수의 값을 변경할 수 있습니다. 


    ```java 
    public class Car {

    String model;
    int speed;


    public void speedUp(int speed){ //속도를 올림
        this.speed += speed; //매개변수 a = 지역변수 //나중에 변수이름은 의미 있는 이름으로 ..
         //안에 speed가 없으면 자동으로 this.가 붙어서 this.speed -> speed 변수가 바뀐다!
    }
    ```

    
- 계산기도 만들어 봤습니다.
 - 클래스 내 메소드는 동일한 이름으로 여러개를 만들 수도 있습니다. 단 주의할 것은 argument의 개수와 타입이 달라야 합니다. 왜냐하면 우리가 코드를 작성하면서 정한 이름이 아니라 컴파일 하면서 메소드명_arg타입_arg타입 이런식으로 이름이 정해집니다. 따라서 argument의 갯수와 타입이 다르다면 명칭이 같아도 오류가 나지 않습니다. 이렇게 동일한 이름의 메소드를 설정하는것을 메소드 오버로딩이라고 한다고 합니다.
 
 - argument 여러개 추가될 때 마다 계속 매소드 생성해도 되지만,java는 가변길이 인자 지원합니다. argument를 입력 하는대신, (int ...v)를 넣으면 배열의 형태로 여러 인자를 입력할 수 있습니다. 이때 가변인자 뿐만 아니라 고정인자(?)와 가변인자를 함께 입력하도록 할 수도 있는데 이 경우에는 고정인자를 먼저 입력 하도록 메소드를 작성하여야 합니다. 

- 기타 
    - 클래스 정의 할 때 특성+ 행동으로 나누어서  필드영역/메소드 영역으로 작성해야하는데, 메소드 영역이 아닌 부분에서 명령문 삽입 하면 안된다.

    - 하나의 java 소스파일 안에 여러 class를 넣어서 여러 객체와 메인 메소드(?)를 작성할 수도 있습니다. 다만 이 때에는 java 파일 이름과 class의 이름을 정할 때 주의하여야 함을 배웠습니다. 


## 🥳오늘 느낀 것 
오늘도 많은 것을 배웠습니다. 복잡해지고 정신이 없어지면서 java에 대한 흥미가 점점 늘고 있습니다(???). 분명 수업시간에 훨씬 더 많은 것들을 배웠는데ㅠㅠ... 빠트린것이 많은 것 같아서 복습을 꼼꼼하게 해야겠습니다. 