---
title: 강의 2021-12-04 모든 개발자를 위한 HTTP 웹 기본 지식
tags: [김영한, HTTP]
categories: 강의
---

# 강의 소개 

우리가 개발하는 모든 것은 http에 기반합니다. 
그래서 http 를 잘 알고 다룰 줄 알아야 합니다. 
깊이 있게 웹 개발을 공부하기 위해서는 http 를 먼저 잘 알아두어야합니다. 

## 강의 목표 
http의 전체 흐름을 이해하고, 
실무에 꼭 필요한 핵심 내용을 배울 것 입니다. 

# 인터넷 네트워크

웹,http 는 인터넷 네트워크 망을 이용해서 접속 하기 때문에, 사전 지식으로 인터넷 네트워크에 대해 배워봅시다. 

## 인터넷 통신
인터넷 상에서 컴퓨터와 컴퓨터끼리는 어떻게 연결 되는걸까? 
한 컴퓨터에서 보낸 메시지는 수많은 노드(서버)를 거쳐서 다른 컴퓨터로 전달 됩니다. 

## IP(인터넷 프로토콜)

인터넷 망에서 메시지를 전달 하기 위해 인터넷 망을 거쳐 가게 되는데, 
이 전달 과정에서 사용되는 규칙이 바로 IP 입니다. 

클라이언트와 메시지를 전달 받는 서버 모두 IP 주소를 가지고 있어야 합니다. 
IP 는 인터넷으로 IP 주소로 메시지를 전달 할 수 있도록 하는 규칙 입니다. 

IP 패킷이라는 단위로 데이터가 전달 됩니다. 소포 상자 같은 것인데, 
패킷에는 보내는 사람의 IP 주소와 서버의 IP 주소가 표시되고, 그 안에 메시지가 들어있습니다. 

노드 끼리 (연결된 컴퓨터 끼리 ) IP 주소를 확인해가면서 패킷을 다시 던져서 최종 목적지에 도달할 때까지 
계속 던져요. 그러면 중간에 잡아 채면...그거시 해킹?

### 참고 : 패킷 ? 

패킷이란 패키지와 버킷의 합성어 입니다. 


### IP 프로토콜의 한계 

- 비연결성 
  - 패킷을 받을 대상이 없어도 패킷이 전송 됩니다. 패킷을 받을 대상의 상태를 확인하지 않기 때문입니다. 
- 비신뢰성 
  - 전달 방법으로 인한 문제 입니다. 
    - 패킷이 중간에 사라질 수 도 있고,
    - 패킷이 순서대로 오지 않을 수도 있습니다. 
- 프로그램 구분 
  - 하나의 IP 주소에서 여러개 어플리케이션을 쓰고 있다면 어디로 보낼 것 인가?! 

## TCP, UDP

### 인터넷 프로토콜 스택의 4 계층 

애플리케이션 계층 - HTTP,FTP  // 웹브라우저, 프로그램 

전송 계층 - TCP,UDP // OS

인터넷 계층 - IP 

네트워크 인터페이스 계층 // 하드웨어 


### TCP 
IP 프로토콜의 한계를 극복하기 위한 프로토콜 입니다. 
IP 패킷은 출발지와 목적지의 정보가 들어간다면,
TCP 패킷의 겉에는 출발지 PORT, 목적지 PORT와 전송 제어, 순서, 검증 정보 등이 들어갑니다. 

#### TCP 의 특징
- TCP 는 전송 제어 프로토콜 입니다. 
- 연결 지향 프로토콜입니다. 3 Way handshake
  - 클라이언트가 먼저 SYN 이라는 접속 요청 메시지를 보냅니다. 
  - 그리고 메시지를 받은 서버 쪽에서도 요청을 수락 하는 ACK 메시지를 보내고 SYN 메시지를 함께 보냅니다. 
  - SYN 메시지를 받은 클라이언트도 다시 ACK 메시지를 보냅니다. 
  - 연결을 확실히 확인 하는군요. 
    - 이 연결은 진짜 물리적인 연결은 아닙니다. 
    - 인터넷 연결망에 둘다 살아 있구나! 하는걸 아는 것 이라고 생각하면 될 것 같습니다. 
- 위와 같이 연결을 확인한 후 데이터를 전달 하므로 데이터 전달이 보장됩니다.
  - 데이터를 전송 해서 상대방이 받으면, 받았다는 메시지를 다시 보내주므로, 전송되었는지를 확인할 수 있습니다. 
- 순서가 보장됩니다. 
  - 데이터가 커서 패킷을 쪼개서 보냈을 경우, 전송제어, 순서, 검증 정보들을 확인하기 때문에 순서가 보장됩니다. 

  
### UDP (사용자 데이터그램 프로토콜) 특징 
- 기능이 거의 없습니다?? 
- PORT 와 체크섬 정보가 들어갑니다. 
  - 하나의 IP 주소에서 데이터를 전달 받을 어플리케이션을 확인할 수 있습니다. 
- 단순하고 빠르게 데이터를 전달 받을 수 있습니다. 

## PORT

클라이언트가(제가)  게임, 화상통화, 웹브라우저를 한번에 하고 있을 경우에는 여러 서버랑 통신을 해야하는데, 
패킷들이 날라올 때, 어떤 프로그램에 필요한 패킷인지 구분 되어야합니다. 

그래서 IP 만으로는 해결 할 수 가 없고, 이 안에서 어떤 프로그램이 목적지 인지 알려주는 PORT 가 필요합니다. 
그러니까 IP 주소는 아파트 또는 주택의 주소 라면, 다세대 주택의 경우에는 한 건물에 여러 세대가 살고 있으니까 
올바른 세대에 나눠 줘야 하는데 PORT 가 몇 층의 몇 호 실 을 표시해주는 것 과 같다고 볼 수 있어요. 

포트는 0~65535 까지 할당 가능한데, 
0~ 1023 은 중요한 애들이 이미 사용하고 있을 수 있으니, 임의로는 사용하지 않는 것이 좋습니다. 

## DNS(도메인 네임 시스템)

IP 는 기억하기가 어렵습니다. 그리고 변경 될 수 있습니다.
그래서 사용하기 어려워요. 
이런 사용하기 어려운 한계를 극복하기 위해 전화번호부 처럼 이름과 아이피를 등록해주는 것이 바로 DNS 서버 입니다. 
음 .. IP 가 좌표 라면 DNS 는 도로명 주소와 같다고 볼 수도 있겠군여...? 

# URI 와 웹 브라우저 요청 흐름

## URI Uniform Resource Identifier 

### URI , URL , URN? 
- URI 는 리소스를 식별합니다. 
  - 이 안에 포함되는 개념이 URL 과 URN 이에요. 
    - URL은 Resource Locator 입니다. (해당 리소스의 주소)
      - 웹브라우저의 주소줄 입니다.
      - 리소스의 위치를 지정 합니다. 
    - URN은 Resource의 이름 이에요. 
      - 위 주소에 이름을 부여하는 것 입니다. 
        - 이 이름만으로는 실제 리소스를 찾을 수 가 없어요. 
  - URI 뜻 
    - Uniform : 리소스를 식별하는 통일된 방식 
    - Resource : URI 로 식별할 수 있는 모든 것을 자원이라고 합니다. 
    - Identifier: 다른 항목과 구분 할 수 있는 정보 
  - URL 분석 
    - https://www.google.com/search?q=Hello&&hl=ko
    - scheme://[userinfo@host[:port]][/path][?query][#fragment]
      - scheme 에는 프로토콜 정보가 들어갑니다. 
        - 프로토콜은 어떤 방식으로 자원에 접근할 것 인가 하는 규칙 입니다. 
          - Http 와 https, ftp 등이 있습니다. 
          - http 는 80, https 는 443 포트를 보통 사용하는데 생략 가능합니다. 
      - userinfo@ 는 거의 사용하지 않는데 url에 사용자 정보를 포함해서 인증해야할 때 사용합니다. 
      - 호스트명에는 도메인 명이나 IP 주소를 직접 입력 할 수있습니다. 
      - path 는 리소스가 있는 경로 입니다. 보통 관리를 위해 계층적 구조로 되어있습니다. 
      - query parameter(string) 는 key=value의 형태로 되어있습니다. 
      - fragment 는 서버로 전송되는 정보는 아니지만, html 내에서 이동할 때 사용합니다. 
      
  
## 웹 브라우저 요청 흐름

- 클라이언트 웹브라우저에서 일어나는 일 
  - URI/URL -> http 요청 메시지 만들기 
    - DNS 를 먼저 조회 합니다. 
    - 그리고 IP 를 가져와요.
    - 웹브라우저는 위에서  찾아온 정보를 가지고 http 요청 메시지를 만듭니다. 
- 클라이언트와 서버간 연결 
  - socket 라이브러리를 통해서 서버와 TCP/IP 연결을 합니다.
  - 패킷 던지기 
    - 패킷이 생성 되고 이 패킷이 서버를 향해 떠납니다. 
    - 패킷이 서버에 도착하면 패킷 껍데기는 버리고 메시지를 찾아냅니다. 
  - 서버는 메시지를 읽고 요청을 처리 합니다. 
    - 처리가 끝난 후에는 http 응답 메시지 를 만들어요. 
    - 이제 이 메시지를 패킷으로 만들어요
    - 그리고 패킷을 다시 클라이언트에게 보냅니다. 
- 마지막으로 웹브라우저가 패킷을 받아서 html 랜더링을 해서 화면을 보여줍니다. 

# HTTP 기본
HTTP는 Hyper Text Transfer Protocol 의 약자 입니다. 
hyper text는 책과 같이 텍스트의 관계가 연결되어 있는 것이 아니라, 
언제든 어떻게든 연결할 수 있는 하이퍼링크로 연결된 텍스트 를 말합니다. 
책의 텍스트는 위에서 아래 또는 왼쪽에서 오른쪽 등의 순서가 있고,  1페이지에서 10페이지로 가려면 모든 페이지를 거쳐 가야하지만 
웹페이지의 경우에는 이러한 순서가 없는 개별적인 텍스트들을 링크 같은 것들을 이용해서 연결할 수 있어요. 

클라이언트와 서버가 이 hypertext 를 주고 받기 위해 정한 표준 규칙이 바로 http 입니다. 


## 모든 것이 HTTP
문서라고 했지만, 사실 요즘에 들어선 text 뿐 아니라 모든 데이터, 이미지, 음성,영상, 파일 들도 http 로 전송된다고 해요.
그리고 서버간 데이터를 주고 받을 때도 http 를 사용한다고 해요.

### http 역사 
- 0.9 : 초창기 버전 
- **1.1** : 가장 중요한 버전입니다. 현재 사용하는 대부분 기능이 여기에 있습니다. (RFC7230 ~ 7235)
- 2 : 성능 개선
- 3 : 진행중 TCP 대신 UDP 사용, 성능 개선 

### HTTP의 특징 
- 클라이언트 서버 구조 
- 무상태 프로토콜(스테이스리스), 비연결성 
- http 메시지 
- 단순함, 확장 가능성 


## 클라이언트 서버 구조

클라이언트가 http 메시지를 보내서 서버에 요청을 보냅니다. 

그리고 클라이언트는 서버로 부터 응답메시지가 올때까지 대기 합니다. 

서버는 요청에 대한 결과를 만들어서 응답 합니다. 

이렇게 개념적으로 서버와 클라이언트를 분리하는것이 중요합니다. 
비지니스로직, 데이터는 서버에서 모두 처리 하고 
클라이언트는 사용성과 UI 에 집중 합니다. 
위와 같이 서버와 클라이언트가 집중해야할 분야를 나누면, 각자의 역할에 따라 독립적으로 진화 시킬 수 있습니다. 


## Stateful, Stateless

### Stateful
stateful 은 상태를 유지한다는 뜻 입니다. 
밑도 끝도 없이 상태를 유지한다, 하지 않는다는 것이 잘 이해가 가지 않았는데, 
요청과 응답을 기초로 하는 클라이언트 - 서버 구조를 사람과 사람간의 관계로 빗대서 이해하면 조금 잘 이해가 되는 것 같습니다. 

단 1번의 요청과 응답만으로 끝나는 것이 아니라, 최종적인 요청을 위해 여러 단계를 거친 요청과 응답이 필요하다고 해봅시다. 

여러 요청-응답이 반복 된다고 한다면 이전 요청과 현재 요청, 그리고 앞으로 요청 들 사이에 
맥락이 있을거에요. 모든 요청이 끝날 때 까지 맥락이 이어지는 것이 stateful 입니다. 서버와 클라이언트가 모두 각 단계의 요청을 기억 하고 있어요. 

### Stateless
그런데 이 경우, 내(클라이언트)가 말했던 사람이 아닌 다른 사람(서버),즉 문맥을 알지 못하는 사람한테 그 다음 요청을 하면 
응답할 수 없다는 문제가 있어요.  

예를 들어서 점원 A와 제가 어떤 물건을 사기 위해 정보를 주고 받다가 점원 A에게 물건을 사면 점원 A는 문맥을 알고 있으니 결제를 바로 해줄 수 있지만, 
점원 A에게 물어보다가 대화 사실도 알지못하는 점원 B 한테 가서 "아 그거 결제할게요 " 하면 점원 B는 속으로 미친놈인가 ? 하면서 어떤걸 말씀하시는건가요? 고객님 ^ㅆ^ 할 것 입니다.


그렇다면, 점원 A,B,C 누구에게든 어떤 단계에서든 요청을 하고 응답을 바로 받으려면 어떻게 해야할까요? 
각 단계에서 서버(점원 A,B,C )는 클라이언트와의 요청, 응답을 기억하지 않고, 클라이언트가 모든 요청을 기억하고 있으면 됩니다! 
이것도 역할과 책임의 분리인가...? 아무튼.. 이렇게 각 단계별로 필요한 것들을 모두 클라이언트가 기억하고 있어요. 그래서 서버는 요청이 들어온 그대로 처리를 해서 응답해주기만 하면 되는 것이 바로 stateless 입니다.  



## Stateless 의 장점 
- stateless의 경우 클라이언트가 보내는 정보를 보고 응답만 하면 되므로, 확장을 편하게 할 수 있습니다. 
- (반면 stateful은 항상 같은 서버가 유지 되어야하고, 클라이언트가 요청한 정보를 모두 서버가  가지고 있어야 합니다. )

## Stateless 단점 
- 무상태로 설계 할 수 없는 경우도 있습니다. 
- 클라이언트가 요청을 하기 위해서 데이터를 많이 보내야합니다. 


## 비 연결성(connectionless)
### 연결을 유지 하는 모델 
TCP/IP는 연결을 유지 합니다. 
많은 클라이언트와 서버가 연결되어있는 동안 서버의 자원이 소모 됩니다. 

### 연결을 유지 하지 않는 모델 
클라이언트와 서버 사이에 요청과 응답을 주고 받으면 연결을 끊어버립니다. 
그러니까 필요한 경우에만 서버의 자원을 사용하고, 요청이 없는 동안은 자원을 사용하지 않습니다. 


### HTTP 는 ?

연결을 유지 하지 않는 모델 입니다. 
그래서 초단위 이하의 빠른 속도로 응답 할 수 있고, 
수천명이 서비스를 사용해도 실제 서버에서 동시 처리 하는 요청이 매우 적습니다. 

### 비연결성의 단점 
클라이언트에게 화면을 보여주기 위해 Html뿐 아니라 자바스크립트, CSS, 이미지 등의
자원들이 함께 다운로드 되야 합니다. 
요청과 응답을 한번 주고 받으면 연결이 끊어지기 때문에,자원이 필요할 때 마다 연결을 계속 반복 해야합니다.  


### 비연결성의 한계 극복 
http 초기에는 html과 html에 필요한 자원들을 받기 위해 연결을 계속 반복 하였지만, 
현재는 http 지속 연결로 한계를 극복하였습니다. 

http 지속연결을 하면 연결 이후 내부 매커니즘에 따라  html 에 필요한 모든 자원을 받을 때까지 연결이 유지 됩니다. 

http2,3 은 지속연결의 효율성을 더 높였습니다. 

## 요약 : 스테이리스를 기억 하자 

같은 시각에 맞춰 발생하는 대용량의 트래픽이 발생할 때는 비연결성도 답이 없기 때문에,
최대한 스테이리스하게 개발을 해야합니다. 

예 : 저녁 6시 선착순 치킨 쿠폰 지급 이벤트, 수강신청 

## HTTP 메시지
HTTP 로 모든 데이터 타입을 전송할 수 있습니다. 
HTTP의 요청메시지와 응답메시지는 구조가 다릅니다. 
- HTTP 메시지 구조 
  - 구조 
    - start-line 시작라인
      - request-line(요청 메시지) = method(get/post) SP(공백) request-target SP HTTP-version SP
        - method : 
          - get : 리소스 조회 (서버한테 리소스 달라고 하는 것 )
          - post : 요청 내역 처리 (리소스 줄테니까 처리 해달라고 하는 것 )
          - put, delete ...
        - 요청 대상 : 
          - 절대 경로[?쿼리]
  
      - status-line(응답 메시지)
        - HTTP-version SP status-code SP reason-phrase CRLF
        
    - header
      - header-field = field-name ":" OWS field-value OWS (OWS : 띄어쓰기 허용) 
      - field-name은 대소문자 구분 하지 않습니다. 
      - 용도 : 
        - http 전송에 필요한 모든 부가정보를 넣습니다. 
          - 메시지 바디 내용, 크리, 압축, 인증, 브라우저 정보 등등 ... 
          
    - empty line 공백 라인(CRLF)
    - message body 
      - 실제 전송할 데이터가 들어갑니다. 
      - byte 로 표현할 수 있는 모든 데이터가 들어갑니다. 

  - 요청메시지 
    - start-line : GET /search?q=hello&... HTTP/1.1
    - header : host:www.google.com
    - empty line 
    - (message body)
  - 응답 메시지 
    - start-line : HTTP/1.1 200 OK
    - header 
    - empty line 
    - message body 
    
# HTTP 메서드
## HTTP API를 만들어보자
### 요구 사항 
- 회원 목록 조회 
- 회원 조회 
- 회원 등록 
- 회원 수정 
- 회원 삭제 

### API URI 설계 

#### 어떻게 설계해요? 
- 회원 목록 조회 /read-member-list
- 회원 조회 /read-member-by-id 
- 회원 등록 /create-member 
- 회원 수정 /update-member
- 회원 삭제 /delete-member

이렇게 해도 되는걸까? 

#### 리소스 식별  
- 리소스의 의미 
  - 회원 등록,수정, 조회 등은 리소스가 아닙니다. 
  - 미네랄을 캐라 -> 미네랄이 리소스 입니다.  
- 리소스를 어떻게 식별? 
  - 회원을 등록, 수정, 조회 하는 것은 모두 배제 합니다. 
  - 회원이라는 리소스만 식별 하면 됩니다. 

#### 리소스와 행위를 구별하자! 
- 리소스는 자원으로서 서버가 뭔가 처리해야할 대상 입니다. 
- URI는 리소스만 식별 하게 해야합니다. 위에서 말했던 것 처럼 뭔가 해야할 일은 모두 배제 합니다. 
- 그렇다면 각각의 행위는 어떻게 구별 하고 맵핑할까요?!  http 메서드로 해결 합니다. 


## HTTP 메서드 - GET, POST
### HTTP 메서드 종류 
- http 메서드는 클라이언트가 서버에 요청할 때 기대하는 행동 입니다. 
- 주요 메서드 
  - GET : 리소스 조회
  - POST : 요청 데이터 처리 (주로 등록)
  - PUT : 클라이언트에서 서버로 리소스를 보내는데, 이 리소스로 대체 해달라는 것입니다.
  - PATCH : 리소스를 부분적으로 변경하는 것 입니다. 
  - DELETE : 리소스 삭제 
- 기타 메서드 
  - HEAD : 메시지를 제외하고 상태줄과 헤더만 반환하라는 것 
  - OPTIONS 
  - CONNECT 
  - TRACE 

### GET 
- URI 에 있는 자원을 달라는 것 입니다. 
- 서버에 전달하고 싶은 데이터는 query 로 전달합니다. 
- 메시지 바디로 데이터를 전달 할 수는 있지만, 권장하지 않습니다.
- 조회 데이터는 GET 을 쓰는게 유리합니다. GET 으로 오면 캐싱을 하는데, POST는 캐싱하기가 어렵기 떄문이라고 합니다. 

### POST 
- 기능 
  - 클라이언트 가 데이터를 전달해서 서버에 처리해달라고 요청 하는 것 입니다. 
  - 리소스 URI 에 POST 요청이 오면, 서버에서 정하는 프로세스로 데이터를 처리하는 것 입니다. 
  - 메시지 바디를 통해 서버로 요청 데이터를 전달합니다. 
  

- 사용 
  - 주로 신규 리소스를 등록 하는데 사용됩니다. 
  - 리소스와 행위를 완전히 분리 할 수 없는 경우 컨트롤 URI(행위를 URI로 맵핑하는 것 )을 쓰는데 이때도 POST 를 사용합니다. 
  - 다른 메서드로 처리 하기 애매한경우 
    - 예를 들어 JSON 으로 조회 데이터를 넘겨야 하는 경우 GET 메서드는 메세지 바디를 허용하지 않는 경우가 많아서 처리 하지 못하는데, 이때도 POST 를 사용합니다. 

  
## HTTP 메서드 - PUT, PATCH, DELETE
### PUT 
put 은 리소스를 **완전히** 대체하는 것 입니다. 
파일을 폴더에 넣는것과 같습니다. 폴더 안에 같은 이름의 파일이 이미 존재 한다면 덮어쓰기 하고,  없으면 생성 됩니다. 

#### PUT 과 POST 차이 
중요한 것은 클라이언트가 리소스를 정확히 알고 있습니다. 
이 것이 POST 와 다른 점 입니다. 
POST 클라이언트가 자원의 종류만 알고 있으면 데이터를 넘겨서 서버가 자원을 입력 또는 처리 해주는 것 이지만, 
PUT은 변경할 자원의 구체적인 위치를 지정합니다. 

### PATCH 

patch는 리소스의 일부분만 변경할 수 있습니다. 
patch를 지원 하지 않는 경우, POST를 사용하면 됩니다. 

### DELETE 
해당 리소스를 삭제 합니다. 

## HTTP 메서드의 속성

# HTTP 메서드 활용
## 클라이언트에서 서버로 데이터 전송
## HTTP API 설계 예시

# HTTP 상태코드
## HTTP 상태코드 소개
## 2xx - 성공
## 3xx - 리다이렉션1
## 3xx - 리다이렉션2
## 4xx - 클라이언트 오류, 5xx - 서버 오류

# HTTP 헤더1 - 일반 헤더
## HTTP 헤더 개요
## 표현
## 콘텐츠 협상
## 전송 방식
## 일반 정보
## 특별한 정보
## 인증
## 쿠키

# HTTP 헤더2 - 캐시와 조건부 요청
## 캐시 기본 동작
## 검증 헤더와 조건부 요청1
## 검증 헤더와 조건부 요청2
## 캐시와 조건부 요청 헤더
## 프록시 캐시
## 캐시 무효화