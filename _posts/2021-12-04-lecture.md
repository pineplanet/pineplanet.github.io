---
title: 강의 2021-12-04 모든 개발자를 위한 HTTP 웹 기본 지식
tags: [김영한, HTTP]
categories: 강의
---

# 강의 소개 

우리가 개발하는 모든 것은 http에 기반합니다. 
그래서 http 를 잘 알고 다룰 줄 알아야 합니다. 
깊이 있게 웹 개발을 공부하기 위해서는 http 를 먼저 잘 알아두어야합니다. 

## 강의 목표 
http의 전체 흐름을 이해하고, 
실무에 꼭 필요한 핵심 내용을 배울 것 입니다. 

# 인터넷 네트워크

웹,http 는 인터넷 네트워크 망을 이용해서 접속 하기 때문에, 사전 지식으로 인터넷 네트워크에 대해 배워봅시다. 

## 인터넷 통신
인터넷 상에서 컴퓨터와 컴퓨터끼리는 어떻게 연결 되는걸까? 
한 컴퓨터에서 보낸 메시지는 수많은 노드(서버)를 거쳐서 다른 컴퓨터로 전달 됩니다. 

## IP(인터넷 프로토콜)

인터넷 망에서 메시지를 전달 하기 위해 인터넷 망을 거쳐 가게 되는데, 
이 전달 과정에서 사용되는 규칙이 바로 IP 입니다. 

클라이언트와 메시지를 전달 받는 서버 모두 IP 주소를 가지고 있어야 합니다. 
IP 는 인터넷으로 IP 주소로 메시지를 전달 할 수 있도록 하는 규칙 입니다. 

IP 패킷이라는 단위로 데이터가 전달 됩니다. 소포 상자 같은 것인데, 
패킷에는 보내는 사람의 IP 주소와 서버의 IP 주소가 표시되고, 그 안에 메시지가 들어있습니다. 

노드 끼리 (연결된 컴퓨터 끼리 ) IP 주소를 확인해가면서 패킷을 다시 던져서 최종 목적지에 도달할 때까지 
계속 던져요. 그러면 중간에 잡아 채면...그거시 해킹?

### 참고 : 패킷 ? 

패킷이란 패키지와 버킷의 합성어 입니다. 


### IP 프로토콜의 한계 

- 비연결성 
  - 패킷을 받을 대상이 없어도 패킷이 전송 됩니다. 패킷을 받을 대상의 상태를 확인하지 않기 때문입니다. 
- 비신뢰성 
  - 전달 방법으로 인한 문제 입니다. 
    - 패킷이 중간에 사라질 수 도 있고,
    - 패킷이 순서대로 오지 않을 수도 있습니다. 
- 프로그램 구분 
  - 하나의 IP 주소에서 여러개 어플리케이션을 쓰고 있다면 어디로 보낼 것 인가?! 

## TCP, UDP

### 인터넷 프로토콜 스택의 4 계층 

애플리케이션 계층 - HTTP,FTP  // 웹브라우저, 프로그램 

전송 계층 - TCP,UDP // OS

인터넷 계층 - IP 

네트워크 인터페이스 계층 // 하드웨어 


### TCP 
IP 프로토콜의 한계를 극복하기 위한 프로토콜 입니다. 
IP 패킷은 출발지와 목적지의 정보가 들어간다면,
TCP 패킷의 겉에는 출발지 PORT, 목적지 PORT와 전송 제어, 순서, 검증 정보 등이 들어갑니다. 

#### TCP 의 특징
- TCP 는 전송 제어 프로토콜 입니다. 
- 연결 지향 프로토콜입니다. 3 Way handshake
  - 클라이언트가 먼저 SYN 이라는 접속 요청 메시지를 보냅니다. 
  - 그리고 메시지를 받은 서버 쪽에서도 요청을 수락 하는 ACK 메시지를 보내고 SYN 메시지를 함께 보냅니다. 
  - SYN 메시지를 받은 클라이언트도 다시 ACK 메시지를 보냅니다. 
  - 연결을 확실히 확인 하는군요. 
    - 이 연결은 진짜 물리적인 연결은 아닙니다. 
    - 인터넷 연결망에 둘다 살아 있구나! 하는걸 아는 것 이라고 생각하면 될 것 같습니다. 
- 위와 같이 연결을 확인한 후 데이터를 전달 하므로 데이터 전달이 보장됩니다.
  - 데이터를 전송 해서 상대방이 받으면, 받았다는 메시지를 다시 보내주므로, 전송되었는지를 확인할 수 있습니다. 
- 순서가 보장됩니다. 
  - 데이터가 커서 패킷을 쪼개서 보냈을 경우, 전송제어, 순서, 검증 정보들을 확인하기 때문에 순서가 보장됩니다. 

  
### UDP (사용자 데이터그램 프로토콜) 특징 
- 기능이 거의 없습니다?? 
- PORT 와 체크섬 정보가 들어갑니다. 
  - 하나의 IP 주소에서 데이터를 전달 받을 어플리케이션을 확인할 수 있습니다. 
- 단순하고 빠르게 데이터를 전달 받을 수 있습니다. 

## PORT

클라이언트가(제가)  게임, 화상통화, 웹브라우저를 한번에 하고 있을 경우에는 여러 서버랑 통신을 해야하는데, 
패킷들이 날라올 때, 어떤 프로그램에 필요한 패킷인지 구분 되어야합니다. 

그래서 IP 만으로는 해결 할 수 가 없고, 이 안에서 어떤 프로그램이 목적지 인지 알려주는 PORT 가 필요합니다. 
그러니까 IP 주소는 아파트 또는 주택의 주소 라면, 다세대 주택의 경우에는 한 건물에 여러 세대가 살고 있으니까 
올바른 세대에 나눠 줘야 하는데 PORT 가 몇 층의 몇 호 실 을 표시해주는 것 과 같다고 볼 수 있어요. 

포트는 0~65535 까지 할당 가능한데, 
0~ 1023 은 중요한 애들이 이미 사용하고 있을 수 있으니, 임의로는 사용하지 않는 것이 좋습니다. 

## DNS(도메인 네임 시스템)

IP 는 기억하기가 어렵습니다. 그리고 변경 될 수 있습니다.
그래서 사용하기 어려워요. 
이런 사용하기 어려운 한계를 극복하기 위해 전화번호부 처럼 이름과 아이피를 등록해주는 것이 바로 DNS 서버 입니다. 
음 .. IP 가 좌표 라면 DNS 는 도로명 주소와 같다고 볼 수도 있겠군여...? 

# URI 와 웹 브라우저 요청 흐름

## URI Uniform Resource Identifier 

### URI , URL , URN? 
- URI 는 리소스를 식별합니다. 
  - 이 안에 포함되는 개념이 URL 과 URN 이에요. 
    - URL은 Resource Locator 입니다. (해당 리소스의 주소)
      - 웹브라우저의 주소줄 입니다.
      - 리소스의 위치를 지정 합니다. 
    - URN은 Resource의 이름 이에요. 
      - 위 주소에 이름을 부여하는 것 입니다. 
        - 이 이름만으로는 실제 리소스를 찾을 수 가 없어요. 
  - URI 뜻 
    - Uniform : 리소스를 식별하는 통일된 방식 
    - Resource : URI 로 식별할 수 있는 모든 것을 자원이라고 합니다. 
    - Identifier: 다른 항목과 구분 할 수 있는 정보 
  - URL 분석 
    - https://www.google.com/search?q=Hello&&hl=ko
    - scheme://[userinfo@host[:port]][/path][?query][#fragment]
      - scheme 에는 프로토콜 정보가 들어갑니다. 
        - 프로토콜은 어떤 방식으로 자원에 접근할 것 인가 하는 규칙 입니다. 
          - Http 와 https, ftp 등이 있습니다. 
          - http 는 80, https 는 443 포트를 보통 사용하는데 생략 가능합니다. 
      - userinfo@ 는 거의 사용하지 않는데 url에 사용자 정보를 포함해서 인증해야할 때 사용합니다. 
      - 호스트명에는 도메인 명이나 IP 주소를 직접 입력 할 수있습니다. 
      - path 는 리소스가 있는 경로 입니다. 보통 관리를 위해 계층적 구조로 되어있습니다. 
      - query parameter(string) 는 key=value의 형태로 되어있습니다. 
      - fragment 는 서버로 전송되는 정보는 아니지만, html 내에서 이동할 때 사용합니다. 
      
  
## 웹 브라우저 요청 흐름

- 클라이언트 웹브라우저에서 일어나는 일 
  - URI/URL -> http 요청 메시지 만들기 
    - DNS 를 먼저 조회 합니다. 
    - 그리고 IP 를 가져와요.
    - 웹브라우저는 위에서  찾아온 정보를 가지고 http 요청 메시지를 만듭니다. 
- 클라이언트와 서버간 연결 
  - socket 라이브러리를 통해서 서버와 TCP/IP 연결을 합니다.
  - 패킷 던지기 
    - 패킷이 생성 되고 이 패킷이 서버를 향해 떠납니다. 
    - 패킷이 서버에 도착하면 패킷 껍데기는 버리고 메시지를 찾아냅니다. 
  - 서버는 메시지를 읽고 요청을 처리 합니다. 
    - 처리가 끝난 후에는 http 응답 메시지 를 만들어요. 
    - 이제 이 메시지를 패킷으로 만들어요
    - 그리고 패킷을 다시 클라이언트에게 보냅니다. 
- 마지막으로 웹브라우저가 패킷을 받아서 html 랜더링을 해서 화면을 보여줍니다. 

# HTTP 기본
HTTP는 Hyper Text Transfer Protocol 의 약자 입니다. 
hyper text는 책과 같이 텍스트의 관계가 연결되어 있는 것이 아니라, 
언제든 어떻게든 연결할 수 있는 하이퍼링크로 연결된 텍스트 를 말합니다. 
책의 텍스트는 위에서 아래 또는 왼쪽에서 오른쪽 등의 순서가 있고,  1페이지에서 10페이지로 가려면 모든 페이지를 거쳐 가야하지만 
웹페이지의 경우에는 이러한 순서가 없는 개별적인 텍스트들을 링크 같은 것들을 이용해서 연결할 수 있어요. 

클라이언트와 서버가 이 hypertext 를 주고 받기 위해 정한 표준 규칙이 바로 http 입니다. 


## 모든 것이 HTTP
문서라고 했지만, 사실 요즘에 들어선 text 뿐 아니라 모든 데이터, 이미지, 음성,영상, 파일 들도 http 로 전송된다고 해요.
그리고 서버간 데이터를 주고 받을 때도 http 를 사용한다고 해요.

### http 역사 
- 0.9 : 초창기 버전 
- **1.1** : 가장 중요한 버전입니다. 현재 사용하는 대부분 기능이 여기에 있습니다. (RFC7230 ~ 7235)
- 2 : 성능 개선
- 3 : 진행중 TCP 대신 UDP 사용, 성능 개선 

### HTTP의 특징 
- 클라이언트 서버 구조 
- 무상태 프로토콜(스테이스리스), 비연결성 
- http 메시지 
- 단순함, 확장 가능성 


## 클라이언트 서버 구조

클라이언트가 http 메시지를 보내서 서버에 요청을 보냅니다. 

그리고 클라이언트는 서버로 부터 응답메시지가 올때까지 대기 합니다. 

서버는 요청에 대한 결과를 만들어서 응답 합니다. 

이렇게 개념적으로 서버와 클라이언트를 분리하는것이 중요합니다. 
비지니스로직, 데이터는 서버에서 모두 처리 하고 
클라이언트는 사용성과 UI 에 집중 합니다. 
위와 같이 서버와 클라이언트가 집중해야할 분야를 나누면, 각자의 역할에 따라 독립적으로 진화 시킬 수 있습니다. 


## Stateful, Stateless

### Stateful
stateful 은 상태를 유지한다는 뜻 입니다. 
밑도 끝도 없이 상태를 유지한다, 하지 않는다는 것이 잘 이해가 가지 않았는데, 
요청과 응답을 기초로 하는 클라이언트 - 서버 구조를 사람과 사람간의 관계로 빗대서 이해하면 조금 잘 이해가 되는 것 같습니다. 

단 1번의 요청과 응답만으로 끝나는 것이 아니라, 최종적인 요청을 위해 여러 단계를 거친 요청과 응답이 필요하다고 해봅시다. 

여러 요청-응답이 반복 된다고 한다면 이전 요청과 현재 요청, 그리고 앞으로 요청 들 사이에 
맥락이 있을거에요. 모든 요청이 끝날 때 까지 맥락이 이어지는 것이 stateful 입니다. 서버와 클라이언트가 모두 각 단계의 요청을 기억 하고 있어요. 

### Stateless
그런데 이 경우, 내(클라이언트)가 말했던 사람이 아닌 다른 사람(서버),즉 문맥을 알지 못하는 사람한테 그 다음 요청을 하면 
응답할 수 없다는 문제가 있어요.  

예를 들어서 점원 A와 제가 어떤 물건을 사기 위해 정보를 주고 받다가 점원 A에게 물건을 사면 점원 A는 문맥을 알고 있으니 결제를 바로 해줄 수 있지만, 
점원 A에게 물어보다가 대화 사실도 알지못하는 점원 B 한테 가서 "아 그거 결제할게요 " 하면 점원 B는 속으로 미친놈인가 ? 하면서 어떤걸 말씀하시는건가요? 고객님 ^ㅆ^ 할 것 입니다.


그렇다면, 점원 A,B,C 누구에게든 어떤 단계에서든 요청을 하고 응답을 바로 받으려면 어떻게 해야할까요? 
각 단계에서 서버(점원 A,B,C )는 클라이언트와의 요청, 응답을 기억하지 않고, 클라이언트가 모든 요청을 기억하고 있으면 됩니다! 
이것도 역할과 책임의 분리인가...? 아무튼.. 이렇게 각 단계별로 필요한 것들을 모두 클라이언트가 기억하고 있어요. 그래서 서버는 요청이 들어온 그대로 처리를 해서 응답해주기만 하면 되는 것이 바로 stateless 입니다.  



## Stateless 의 장점 
- stateless의 경우 클라이언트가 보내는 정보를 보고 응답만 하면 되므로, 확장을 편하게 할 수 있습니다. 
- (반면 stateful은 항상 같은 서버가 유지 되어야하고, 클라이언트가 요청한 정보를 모두 서버가  가지고 있어야 합니다. )

## Stateless 단점 
- 무상태로 설계 할 수 없는 경우도 있습니다. 
- 클라이언트가 요청을 하기 위해서 데이터를 많이 보내야합니다. 


## 비 연결성(connectionless)
### 연결을 유지 하는 모델 
TCP/IP는 연결을 유지 합니다. 
많은 클라이언트와 서버가 연결되어있는 동안 서버의 자원이 소모 됩니다. 

### 연결을 유지 하지 않는 모델 
클라이언트와 서버 사이에 요청과 응답을 주고 받으면 연결을 끊어버립니다. 
그러니까 필요한 경우에만 서버의 자원을 사용하고, 요청이 없는 동안은 자원을 사용하지 않습니다. 


### HTTP 는 ?

연결을 유지 하지 않는 모델 입니다. 
그래서 초단위 이하의 빠른 속도로 응답 할 수 있고, 
수천명이 서비스를 사용해도 실제 서버에서 동시 처리 하는 요청이 매우 적습니다. 

### 비연결성의 단점 
클라이언트에게 화면을 보여주기 위해 Html뿐 아니라 자바스크립트, CSS, 이미지 등의
자원들이 함께 다운로드 되야 합니다. 
요청과 응답을 한번 주고 받으면 연결이 끊어지기 때문에,자원이 필요할 때 마다 연결을 계속 반복 해야합니다.  


### 비연결성의 한계 극복 
http 초기에는 html과 html에 필요한 자원들을 받기 위해 연결을 계속 반복 하였지만, 
현재는 http 지속 연결로 한계를 극복하였습니다. 

http 지속연결을 하면 연결 이후 내부 매커니즘에 따라  html 에 필요한 모든 자원을 받을 때까지 연결이 유지 됩니다. 

http2,3 은 지속연결의 효율성을 더 높였습니다. 

## 요약 : 스테이리스를 기억 하자 

같은 시각에 맞춰 발생하는 대용량의 트래픽이 발생할 때는 비연결성도 답이 없기 때문에,
최대한 스테이리스하게 개발을 해야합니다. 

예 : 저녁 6시 선착순 치킨 쿠폰 지급 이벤트, 수강신청 

## HTTP 메시지
HTTP 로 모든 데이터 타입을 전송할 수 있습니다. 
HTTP의 요청메시지와 응답메시지는 구조가 다릅니다. 
- HTTP 메시지 구조 
  - 구조 
    - start-line 시작라인
      - request-line(요청 메시지) = method(get/post) SP(공백) request-target SP HTTP-version SP
        - method : 
          - get : 리소스 조회 (서버한테 리소스 달라고 하는 것 )
          - post : 요청 내역 처리 (리소스 줄테니까 처리 해달라고 하는 것 )
          - put, delete ...
        - 요청 대상 : 
          - 절대 경로[?쿼리]
  
      - status-line(응답 메시지)
        - HTTP-version SP status-code SP reason-phrase CRLF
        
    - header
      - header-field = field-name ":" OWS field-value OWS (OWS : 띄어쓰기 허용) 
      - field-name은 대소문자 구분 하지 않습니다. 
      - 용도 : 
        - http 전송에 필요한 모든 부가정보를 넣습니다. 
          - 메시지 바디 내용, 크리, 압축, 인증, 브라우저 정보 등등 ... 
          
    - empty line 공백 라인(CRLF)
    - message body 
      - 실제 전송할 데이터가 들어갑니다. 
      - byte 로 표현할 수 있는 모든 데이터가 들어갑니다. 

  - 요청메시지 
    - start-line : GET /search?q=hello&... HTTP/1.1
    - header : host:www.google.com
    - empty line 
    - (message body)
  - 응답 메시지 
    - start-line : HTTP/1.1 200 OK
    - header 
    - empty line 
    - message body 
    
# HTTP 메서드
## HTTP API를 만들어보자
### 요구 사항 
- 회원 목록 조회 
- 회원 조회 
- 회원 등록 
- 회원 수정 
- 회원 삭제 

### API URI 설계 

#### 어떻게 설계해요? 
- 회원 목록 조회 /read-member-list
- 회원 조회 /read-member-by-id 
- 회원 등록 /create-member 
- 회원 수정 /update-member
- 회원 삭제 /delete-member

이렇게 해도 되는걸까? 

#### 리소스 식별  
- 리소스의 의미 
  - 회원 등록,수정, 조회 등은 리소스가 아닙니다. 
  - 미네랄을 캐라 -> 미네랄이 리소스 입니다.  
- 리소스를 어떻게 식별? 
  - 회원을 등록, 수정, 조회 하는 것은 모두 배제 합니다. 
  - 회원이라는 리소스만 식별 하면 됩니다. 

#### 리소스와 행위를 구별하자! 
- 리소스는 자원으로서 서버가 뭔가 처리해야할 대상 입니다. 
- URI는 리소스만 식별 하게 해야합니다. 위에서 말했던 것 처럼 뭔가 해야할 일은 모두 배제 합니다. 
- 그렇다면 각각의 행위는 어떻게 구별 하고 맵핑할까요?!  http 메서드로 해결 합니다. 


## HTTP 메서드 - GET, POST
### HTTP 메서드 종류 
- http 메서드는 클라이언트가 서버에 요청할 때 기대하는 행동 입니다. 
- 주요 메서드 
  - GET : 리소스 조회
  - POST : 요청 데이터 처리 (주로 등록)
  - PUT : 클라이언트에서 서버로 리소스를 보내는데, 이 리소스로 대체 해달라는 것입니다.
  - PATCH : 리소스를 부분적으로 변경하는 것 입니다. 
  - DELETE : 리소스 삭제 
- 기타 메서드 
  - HEAD : 메시지를 제외하고 상태줄과 헤더만 반환하라는 것 
  - OPTIONS 
  - CONNECT 
  - TRACE 

### GET 
- URI 에 있는 자원을 달라는 것 입니다. 
- 서버에 전달하고 싶은 데이터는 query 로 전달합니다. 
- 메시지 바디로 데이터를 전달 할 수는 있지만, 권장하지 않습니다.
- 조회 데이터는 GET 을 쓰는게 유리합니다. GET 으로 오면 캐싱을 하는데, POST는 캐싱하기가 어렵기 떄문이라고 합니다. 

### POST 
- 기능 
  - 클라이언트 가 데이터를 전달해서 서버에 처리해달라고 요청 하는 것 입니다. 
  - 리소스 URI 에 POST 요청이 오면, 서버에서 정하는 프로세스로 데이터를 처리하는 것 입니다. 
  - 메시지 바디를 통해 서버로 요청 데이터를 전달합니다. 
  

- 사용 
  - 주로 신규 리소스를 등록 하는데 사용됩니다. 
  - 리소스와 행위를 완전히 분리 할 수 없는 경우 컨트롤 URI(행위를 URI로 맵핑하는 것 )을 쓰는데 이때도 POST 를 사용합니다. 
  - 다른 메서드로 처리 하기 애매한경우 
    - 예를 들어 JSON 으로 조회 데이터를 넘겨야 하는 경우 GET 메서드는 메세지 바디를 허용하지 않는 경우가 많아서 처리 하지 못하는데, 이때도 POST 를 사용합니다. 

  
## HTTP 메서드 - PUT, PATCH, DELETE
### PUT 
put 은 리소스를 **완전히** 대체하는 것 입니다. 
파일을 폴더에 넣는것과 같습니다. 폴더 안에 같은 이름의 파일이 이미 존재 한다면 덮어쓰기 하고,  없으면 생성 됩니다. 

#### PUT 과 POST 차이 
중요한 것은 클라이언트가 리소스를 정확히 알고 있습니다. 
이 것이 POST 와 다른 점 입니다. 
POST 클라이언트가 자원의 종류만 알고 있으면 데이터를 넘겨서 서버가 자원을 입력 또는 처리 해주는 것 이지만, 
PUT은 변경할 자원의 구체적인 위치를 지정합니다. 

### PATCH 

patch는 리소스의 일부분만 변경할 수 있습니다. 
patch를 지원 하지 않는 경우, POST를 사용하면 됩니다. 

### DELETE 
해당 리소스를 삭제 합니다. 

## HTTP 메서드의 속성

### 안전 (Safe)
호출 해도 리소스가 변경 되지 않습니다. (장애 발생은 고려 하지 않습니다.)
Get 은 단순히 조회만 하는 것이기 때문에 안전합니다. 

POST, PUT, PATCH 는 리소스를 변경 하는 것이니 안전하지 않습니다. 

### 멱등 (idempotent)

- 멱등 이란 한번 호출 하든 수만번 호출 하든 결과가 같은 것을 말합니다. 
  - Get 은 리소스 조회를 하기만 하는 것이니, 얼마나 호출 하든 결과가 같습니다. 
  - Put 도 멱등합니다. 처음에 내가 한 PUT 이나 마지막에 한 PUT 이나 결과가 같습니다.
  - DELETE 도 같은 삭제 요청을 여러번 하더라도 하나의 리소스만 지워진 상태 로 남아있으니 똑같습니다. 
  - Post 는 멱등하지 않습니다. 
    - 결제를 2번 하면 중복 결제가 됩니다. 
    - 어떤 요청을 계속 하면 한번 한번 계속 수행하니까요. 
- 활용 
  - 자동 복구 매커니즘 
  - 서버 장애 등의 이유로 서버가 요청에 대한 정상적인 응답을 하지 못했을 때, 클라이언트가 같은 요청을 반복 해도 되는지 판단하는 근거가 됩니다. 
    - Post 의 경우 외에는 다시 요청 해도 되겠죠. 
- 외부 요인으로 인한 리소스 변경? 
  - 멱등의 개념은 클라이언트의 요청-> 리소스의 변경 만으로 판단합니다. 
  - 외부 요인으로 인한 리소스 변경은 고려 하지 않습니다. 
  
### 캐시가능 
- 응답 결과 리소스를 캐시해서 사용해도 되는지 여부 입니다. 
- 캐시란 한번 받은 리소스를 웹브라우저가 내부에 저장하고 있는 것 입니다. 
- GET, HEAD 는 캐시로 사용합니다. 
- POST , PATCH 는 본문 내용까지 캐시 키로 고려해야하는데 구현하기 어려워서 캐시로 사용하지 않습니다. 

# HTTP 메서드 활용
## 클라이언트에서 서버로 데이터 전송

- 데이터 전달방식 2가지 
  - 쿼리 파라미터 전송 
    - 주로 GET 
    - 정렬 필터 사용할 때 
  - 메시지 바디를 통한 데이터 전송 
    - POST,PUT, PATCH
    - 회원 가입, 상품주문, 리소스 등록, 리소스 변경할 때 사용합니다. 

- 클라이언트에서 서버로 데이터 전송 상황 
  - 정적 데이터 조회 
    - 추가적인 데이터 전송 없이 URI 만으로 조회 가능 합니다. 
  - 동적 데이터 조회
    - 조회는 GET 을 사용합니다. 
    - 쿼리 파라미터를 사용합니다. 
    - 검색, 게시판 목록 정렬 필터 할 때 사용합니다(조회 조건을 줄여주거나 정렬 하는데 주로 사용)
  - HTML Form 데이터 전송 (POST/GET 만)
    - Form 태그의 submit 을 누르면 웹브라우저가 http 메시지를 생성해줍니다. 
      - 메시지 Content-Type: application/x-www-form-urlencoded (default)
        - 요기에 보면 urlencoded 이라고 되어있어요. 전송 데이터를 url encoding 처리 해주는 것인데, 그래서 한글이 인코딩되서 깨져요! 
      - body : username=kim&age=20 (쿼리와 유사한 형태)
      - 만약 method 를 get으로 바꾸면 웹브라우저가 메시지바디를 만드는 대신 URL 쿼리로 만들어서 보냅니다. 
    - file 등을 전송할 때 사용하는 content type 은 multipart/form-data 입니다. 
      - 메시지 Content-Type:  multipart/form-data; boundatry= ---XXX
      - body 의 컨텐트를 ---XXX로 구분해서 파트를 나누어 전송합니다. 
  - HTTP API 데이터 전송 
    - 클라이언트의 라이브러리 등을 이용해서 JSON 데이터를 서버로 바로 넘기는 것 입니다. 
    - 사용
      - 서버끼리 통신할 때 보통 쓰입니다. 
      - 애플리케이션 
      - 웹 클라이언트 
        - form 전송 대신 자바스크립트 이용할 때 (AJAX)
    - POST, PUT,PATCH : 메시지 바디로 데이터 전송 
    - GET : 조회, 쿼리 파라미터로 전달 하는 것이 좋습니다.
    - Content-Type : 요즘 대세는 json 입니다. 
  
      
## HTTP API 설계 예시

- HTTP API- 컬렉션
  - POST 기반 등록 
  - 예 (회원관리 API 제공 ) POST와 PUT 
- HTTP API - 스토어 
  - PUT 기반 등록 
  - 예 (정적 컨텐츠 관리, 원격 파일 관리 )
- HTML FORM 사용 
  - 웹페이지 회원 관리 
  - GET,POST 만 지원 

### 회원 관리 시스템 
API 설계 - POST 기반 등록
URI 는 RESOURCE 만을 식별 하도록 해야합니다. 
RESOURCE 에 대한 요청 행위는 행위의 종류에 따라 메소드로 식별 합시다! 


- 회원 목록 : /members -> GET
- 회원 등록 : /members -> POST 
- 회원 조회 : /members/{id} -> GET 
- 회원 수정 : /members/{id} -> PATCH, PUT, POST 
  - PUT = 덮어쓰기 (게시글 수정 등 전체를 모두 수정하는 경우 )
  - PATCH = 일부 수정
  - POST = 애매할 때 
- 회원 삭제 : /members/${id} -> DELETE 

- POST 방식 특징 
  - POST 기반 방식은 리소스를 처리 한 후 리소스 URI 를 서버가 만들어서 클라이언트에게 다시 넘겨줍니다.
  - 클라이언트는 등록될 리소스의 URI를 모릅니다. 서버가 결정하고 보내줘요. 
  - 위와 같은 형식을 컬렉션 이라 합니다. 
    - 서버가 관리하는 리소스 디렉토리로 
    - 서버가 리소스의 URI 를 생성하고 관리 합니다. 
  
### 파일 관리 시스템 
API 설계 - PUT 기반 등록 

- 파일 목록 : /files -> GET
- 파일 조회 : /files/{filename} -> GET
- 파일 등록 : /files/{filename} -> PUT
- 파일 삭제 : /files/{filename} -> DELETE
- 파일 대량 등록 : /files -> POST


- 특징 : 
  - 등록할 때 PUT 을 사용합니다. 
  - PUT의 특징을 위에서 배운 것 처럼 클라이언트가 URI 를 알고 있어야 합니다. 
  - POST 기반 등록은 서버가 리소스  URI 생성, 관리 해주는 것과 구별 됩니다. 
  - 위와 같은 형식을 스토어 라고 합니다. 
    - 클라이언트가 관리하는 리소스 저장소 
    - 클라이언트가 리소스의 URI 를 알고 관리 합니다. 

### HTML FORM 사용 
- HTML FORM 은 GET, POST 만 지원 합니다. (자바스크립트 등의 도움으로 다른 것 도 가능)
- 메서드로 행위를 식별해줄 수가 없기 때문에 URI 로 식별 해야해요(컨트롤 URI)
  - POST, 동사 URI (new, edit, delete)
  - 컨트롤 URI 는 무식하게 쓰면 안되고 정말 해결 안될 때 사용합니다. 
- 설계 
  - 회원 목록 : /members 
  - 회원 등록 폼 : /members/new 
  - 회원 등록 : /members/new(영한님 추천 ) or /members -> POST 
  - 회원 조회 : /members/{id} -> GET 
  - 회원 수정 폼 : /members/{id}/edit -> GET 
  - 회원 수정 : /members/{id}/edit or /members/{id} -> POST 
  - 회원 삭제 : /members/{id}/delete -> POST 


### 참고하면 좋은 URI 설계 개념

- 문서(document)
  - 단일 개념(파일 하나, 객체 인스턴스, 데이터베이스 row)
  - 예) /members/100, /files/star.jpg 
- 컬렉션(collection)
  - 서버가 관리하는 리소스 디렉터리 서버가 리소스의 URI를 생성하고 관리 
  - 예) /members
- 스토어(store)
  - 클라이언트가 관리하는 자원 저장소 클라이언트가 리소스의 URI를 알고 관리 
  - 예) /files 
- 컨트롤러(controller), 컨트롤 URI 
  - 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행 
  - 동사를 직접 사용 
  - 예) /members/{id}/delete

# HTTP 상태코드
## HTTP 상태코드 소개
상태코드란 클라이언트가 보낸 요청의 처리가 잘되었는지를 응답에서 알려주는 기능 입니다. 
1XX ~ 5XX 까지 코드로 알려줍니다. 


## 2xx - 성공
- 의미 
  - 클라이언트가 보낸 요청이 성공적 으로 처리 되었다는 것입니다. 

- 종류 
  - 200 : OK
    - Get 리소스 조회 -> 200 OK! + 리소스 전달 
  - 201 : Created
    - POST 신규 리소스 등록 요청 -> COLLECTION : 서버에서 URI 생성, 관리(로케이션 헤더) 
  - 202 : Accepted 
    - 요청이 접수는 됬는데 처리가 완료되지 않는 경우 
    - 배치 처리 같은 곳 
  - 204 : No Content 
    - 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음
    - 예를 들어 웹 문서 작성 페이지의 save 버튼 


## 3xx - 리다이렉션
- 의미
  - 요청을 완료 하기 위해 유저 에이전트(클라이언트 프로그램 : 웹브라우저) 의 추가 조치가 필요합니다. 
- 리다이렉션 이해 
  - 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동합니다.(리다이렉트)
- 종류 : 
  1. 영구 리다이렉션: 특정 리소스의 URI 가 영구적으로 이동합니다. 
    - 301, 308 이 있는데, 모두 기능은 같습니다. 
      - 301은 요청 메서드가 GET 으로 변할 수 있고, 본문이 제거될 수 있습니다.
        - 처음에 보낼 때 POST 로 보내면서 리소스를 함께 보냈다면, 리다이렉트 할 때는 리소스가 날아갈 수 있어요. 
      - 308은 요청메서드와 본문이 유지됩니다. 
        - 위의 문제를 해결 합니다. 처음에 입력한 그대로 리다이렉션 되서 넘어갑니다. 
        
    - 원래의 URL을 사용 하지 않습니다. 검색 엔진등에서도 변경을 인지 합니다. 
  2. 일시 리다이렉션 : 일시적인 변경 
    - 리소스의 URI가 일시적으로 변경 되는 것 입니다. 그래서 검색엔진 등에서 변경하면 안됩니다. 
    - 실무에서 많이 씁니다. 
    - 302 Found : 리다이렉트 시 본문 메서드가 GET 으로 변하고, 본문이 제거될 수 있습니다(MAY).
    - 307 Temporary Redirect : 메소드와 본문이 유지 됩니다(MUST). 
    - 303 See Other : 리다이렉트 시 요청 메서드가 GET 으로 변경 됩니다.
    - 꼭 필요한 경우 :
      - Post 로 주문 하고 웹 브라우저를 새로고침하면?? -> 중복 주문...
      - 위의 문제를 해결 하기 위해 일시 리다이렉션을 사용합니다. (Post/Redirect/Get)
      - Post로 주문 후에 주문 결과 화면을 GET으로 리다이렉트 합니다. 
      - 새로고침 해도 결과화면을 Get 으로 받아서 리소스를 조회 해옵니다. 그래서 중복 주문이 들어가지 않아요. 

      
  3. 특수 리다이렉션 
      - 결과 대신 캐시를 사용 
      - 300
      - 304 Not Modified
        - 캐시를 목적으로 사용
        - 캐시에 남아있는 데이터를 사용해도 되는지 서버가 확인 해줍니다. 클라이언트가 캐시를 재사용 할 수 있게 합니다.
        - 따라서 메시지 바디를 포함 하면 안됩니다.
    
## 4xx - 클라이언트 오류, 5xx - 서버 오류
### 클라이언트의 문제 -> 4XX 
- 의미 
  - 클라이언트의 요청에 문제가 있어서 서버가 요청을 수행할 수 없음을 말합니다. 
  - 이미 잘못된 요청이므로 재시도를 하더라도 요청 수행이 실패 합니다(500과의 차이)
- 종류 
  - 400 Bad Request : 
    - 요청 구문, 메시지 등의 오류 
    - 요청 파라미터 잘못, API 스펙 맞지 않을 때 
    - 백엔드 개발자들이 철저하게 이 경우 500 오류가 나오지 않게 막아야 합니다. 
  - 401 Unauthorized 
    - 인증이 되지 않음을 알려줍니다. 
    - WWW-Authenticate 헤더와 함께 인증 방법을 설명합니다. 
    - 참고 : 
      - 인증(Authentication) : 본인이 누군지 확인(로그인)
      - 인가(Authorization) : 권한 부여 (관리자 권한 )
      - 이름이 아쉬움 
  - 403 Forbidden
    - 인증 자격 증명은 있지만, 접근 권한이 불충분 한 경우 입니다. 
  - 404 Not Found
    - 요청한 리소스가 서버에 없는데 접근하려고 하기 때문입니다. 
    - 또는 클라이언트가 권한 부족한 리소스에 접근했는데, 403 에러 대신 낼 수 있습니다. 


### 서버의 문제 -> 5XX
- 서버문제로 오류 발생 
- 왠만 하면 500 대 에러를 만들면 안됩니다. 정말 서버에 심각한 문제가 있을 때 와 구별 할 수 있어야 합니다. 
- 종류 : 
  - 애매하면 500 오류 내면 됩니다.
  - 503 Service Unavailable
      - 서버의 일시적 과부하 또는 작업 으로 요청 처리 할 수 없음 입니다.


# HTTP 헤더1 - 일반 헤더
## HTTP 헤더 개요
- 헤더 필드는 field-name, field-value 가 있습니다. 
- 특징: 
  - http 전송에 필요한 모든 부가 정보를 넣습니다. 
  - 표준 헤더가 굉장히 많고, 임의 헤더 추가도 가능합니다. 
- 과거의 헤더 분류 (RFC-2616)
  - General 헤더 : 메시지 전체에 적용되는 정보 
  - Request 헤더: 요청 정보 
  - Response 헤더: 응답 정보 
  - Entity 헤더: 엔티티 바디정보 예) Content-Type: text/html, Content-Length
    - 엔티티 본문의 데이터를 해석할 수 있는 정보를 제공 합니다. 데이터 유형 등 
- (RFC-2616) 폐기 이후 2014년 RFC 723X .. 
  - 엔티티 대신 표현(Representation = Representation Metadata  + Representation Data )으로 변경
    - 표현 이란 요청이나 응답에서 전달할 실제 데이터를 말합니다. 
    - 표현 헤더는 표현 데이터를 해석할 수 있는 정보를 제공합니다. 
  - 메시지 본문을 통해 표현 데이터를 전달 합니다. 
  - 메시지 본문 = 페이로드
  
## 표현
- 표현헤더 내용  
  - Content-Type : 표현 데이터의 형식
    - 바디에 들어가는 내용을 알려줍니다.
    - 미디어 타입과 문자 인코딩 
    
  - Content-Encoding: 표현 데이터의 압축형식 
    - 데이터를 전달하는 곳에서 압축 한 후에 헤더를 추가 합니다. 
    - 받는 쪽에서 이 헤더를 읽고 압축해제할 수 있습니다.

  - Content-Language : 표현 데이터의 자연 언어 를 표현 합니다.
    - ko, en, en-US 등을 표현 하는데, 한국에서 영어 사이트 들어갔을 때 한국어 페이지로 변경하겠냐고 ? 나오는 기능 등 을 지원할 수 이썽요.
    
  - Content-Length : 표현 데이터의 길이
    - 바이트 단위 입니다. 
    - Transfer-Encoding 의 경우에는 사용 하지 않습니다. 
  

## 콘텐츠 협상
- 의미 
  - 클라이언트와 서버 사이에서 클라이언트가 원하는 우선순위에 맞춰서 타입의 미디어 타입을 달라고 요청 하는 것 입니다. 
  - 협상 헤더는 요청시에만 사용합니다. 
- 종류 
  - Accept: 클라이언트가 선호하는 미디어 타입 전달 
  - Accept-Charset : 클라이언트가 선호하는 문자인코딩 타입 전달
  - Accept-Encoding : 클라이언트가 선호하는 압축 인코딩 타입 전달
  - Accept-Language : 클라이언트가 선호하는 자연 언어 전달
- 협상과 우선 순위
  - Quality Values(q)
    - 0-1 사이의 우선 순위를 value 로 전달 할 수 있습니다. 
    - 1 순위 : ko-KR;q=1
    - 2 순위 : ko;q=0.9,
    - 3 순위 : en;q=0.8, ... 
  - 구체적인 것이 우선 합니다. 
  - 구체적인 것을 기준으로 미디어 타입을 맞춥니다. 
  
- 예:
  - 1 번 
    - 다국어를 지원하는 서버에 한국 클라이언트 가 뭔가를 요청 한다고 하면, 
    - 콘텐츠 협상 헤더를 사용하지 않는 경우에는 위 서버의 기본 설정된 언어로 응답 하는데, 
    - Accept-Language 를 붙여서 요청하면, 서버에서 한국어를 지원할 경우 바로 한국어로 응답하게 됩니다. 
  - 2 번 
    - 기본은 독일어 이고, 영어를 지원 하는 서버에 한국 클라이언트가 요청을 할게요. 
    - Accept-Language: ko 헤더를 함께 보냈는데 이 서버는 한국어를 지원하지 않아요.
    - 이 경우 클라이언트가 ko 헤더만 보냈을 경우(우선순위를 지정하지 않았을 경우 ) 독일어로 응답 하지만, 
    - 한국어 다음 우선순위를 영어 로 지정 하여 요청을 보낸다면, 영어로 응답 하게 됩니다. 

## 전송 방식
- 4가지 방식 
  - 단순 전송 
    - 요청을 하면 응답을 주는 content-length를 알 수있을 때, Content-Length를 함께 주면서 전체를 전송 합니다. 
  - 압축 전송 
    - 서버에서 압축을 한 후, 헤더에 Content-Encoding에 어떻게 압축했는지에 대한 정보를 포함 하여 전송 합니다. 
  - 분할 전송 
    - 청크로 내용을 쪼개서 보냅니다. Transfer-Encoding: chunked를 포함 하여 보내고, Content-length는 들어가지 않습니다. 
  - 범위 전송 
    - 클라이언트가 이미지 등을 받다가 중간에 끊긴 경우, 나머지를 끝까지 받기 위해서 범위를 정해서 요청 하고, 서버는 리소스 중 해당 범위의 일부만을 보낼 수 있습니다. 
  
## 일반 정보
단순한 정보성 헤더들 입니다 .
- From : 유저 에이전트의 이메일 정보를 넣어둡니다. 
- Referer(referrer 의 오타...) : 직전의 웹 사이트의 주소 를 담아둡니다. A -> B 로 이동 한 경우 A 주소가 담깁니다. 
- User-Agent : 유저 클라이언트의 애플리케이션 정보 입니다. (웹 브라우저, OS ? ) , 특정 브라우저에서 생기는 문제를 발견하거나, 통계 정보를 추출하는데 도움됩니다. 
- Server : 요청을 처리하는 origin 서버 (실제 응답을 해주는 서버) 의 소프트웨어 정보 
- Date : 메시지가 발생한 날짜와 시간 입니다. 

## 특별한 정보

- Host : 정말 중요한 헤더 입니다. 
  - 요청 에서 사용합니다. 하나의 서버가 여러 도메인을 처리할 때 도메인들을 구분 해줍니다. 
  - 클라이언트는 IP 로만 요청을 하는데, 서버가 여러 도메인 을 가지고 있을 경우, 요청을 어디에 넣어야 할지 문제가 되는데 
  - Host 를 보고 서버가 내부에 있는 도메인 으로 요청을 넣어줍니다. 
- Location : 
  - 3XX 응답 
  - 201 
- Allow : 허용 가능한 Http 메서드 
  - 405 에러 시 해당 서버에서 지원 가능한 메서드를 다시 응답 해야합니다. 
- Retry-After : 503 에러 시 언제까지 서비스 불능인지 알려줍니다. 

## 인증
- Authorization : 클라이언트 인증 정보를 서버에 전달 합니다. 
  - 인증에 관련된 값을 넣어줍니다 (Basic xxxxxxxxxxx ). 
- WWW-Authenticate
  - 401 에러 응답과 함께 사용합니다. 

## 쿠키
- Set-Cookie : 서버에서 클라이언트로 쿠키를 전달 ( 응답 )
  - sessionId (세션 키와 정보를 서버에 담아두고, 키를 쿠키에 넣어서 전달)
  - expires
  - path
  - domain
- Cookie :  클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달 

### 쿠키 개념 
- HTTP 의 Stateless 속성 ( 클라이언트의 요청을 서버가 기억 하지 않습니다. )
- 위의 대안 
  - 쿠키 미사용 : 모든 요청과 링크에 사용자 정보 포함
    - 개발자가 힘들고, 
    - 브라우저를 완전히 종료, 다시 열면? 
  - 쿠키 사용 : 
    - 클라이언트가 로그인 등을 해서 요청으로 넘기면, 
    - 서버는 그 리소스를 쿠키에 넣어서 응답과 함께 보냅니다. Set-Cookie 
    - 그러면 클라이언트 웹 브라우저의 쿠키 저장소에 해당 리소스를 넣어둡니다.
    - 그 다음 부터 클라이언트 웹 브라우저는 쿠키 저장소를 뒤져서 서버에 요청을 보낼 때마다 쿠키를 함꼐 보냅니다.
- 쿠키 정보가 매번 계속 서버에 전송 되니, 내부 트레픽이 증가 해요. 그래서 최소한의 정보만 사용 해야 합니다. 
- 보안에 민감한 데이터는 절대!! 저장 하면 안됩니다. 

### 쿠키 생명 주기 
- Set-Cookie : 
  - expire = GMT 날짜, 
  - max-age : 0 또는 음수를 지정하면 쿠키가 삭제 됩니다. 
- 종류 
  - 세션 쿠키 : 만료 날짜를 생략 하면 브라우저 종료시 까지만 유지 됩니다. 
  - 영속 쿠키 : 만료 날짜를 입력 하면 해당 날짜 까지 쿠키가 유지 됩니다. 

    
### 쿠키 도메인 
- 도메인 명시 : 명시한 문서 기준 도메인  + 서브 도메인 포함 해서 쿠키에 접근할 수 있습니다. 
- 도메인 생략 : 생성한 도메인에서만 쿠키에 접근할 수 있고, 서브 도메인에서는 접근할 수 없습니다.

### 쿠키 경로 
- 이 경로를 포함한 하위 경로 페이지만 쿠키에 접근할 수 있습니다. 

### 쿠키 보안 
- Secure 
  - https 인 경우에만 쿠키를 전송 합니다. 
- HttpOnly 
  - XSS 공격을 방지 합니다. 
  - 자바 스크립트에서는 접근할 수 없습니다. 
  - http 전송에만 사용 
- SameSite 
  - XSRF 공격 방지 
  - 요청 도메인과 쿠키 설정 도메인이 같은 경우에만 쿠키가 전송 됩니다. 

# HTTP 헤더2 - 캐시와 조건부 요청
## 캐시 기본 동작
- 캐시가 없을 때 
  - 클라이언트가 리소스를 요청 하면, 서버가 리소스가 있는지 확인하고 다시 보내줍니다. 
  - 위의 요청을 한번 더 하면 서버는 다시 헤더와 바디에 리소스를 넣어서 다시 보내줍니다. 
  - 이 경우 계속 데이터를 다운로드 받아야하고, 
  - 매우 느리고 비쌉니다. 
- 캐시 적용하면 
  - 최초로 요청할 때는 위와 같이 리소스를 모두 내려주지만, 
  - 응답 결과를 클라이언트의 웹 브라우저의 캐시에 저장하게 합니다. 
  - 그러면 다음 요청 부터는 캐시를 먼저 뒤지고, 유효 기간을 확인한 후, 캐시에서 리소스를 불러오거나 서버에 다시 요청 하게 됩니다. 
  - 이러면 클라이언트 입장에서는 아주 빠르게 응답을 받을 수 있어요.
- 캐시 시간 초과 하면 
  - 서버로 다시 데이터를 조회, 캐시를 갱신 합니다. 
  - 이때 리소스가 같으면 다운로드를 받지 않고 유효 기간만 갱신하게 할 수 있을 것 같아요. 

## 검증 헤더와 조건부 요청1 last modified
검증헤더란 캐시 데이터와 서버데이터가 같은지 검증하는 데이터를 말합니다. 

- 캐시 유효시간 초과 한 경우 
  - 서버에서 기존 데이터를 변경 한 경우 
    - 다시 리소스를 다운로드 하도록 해야합니다. 
  - 서버에서 기존 데이터를 변경 하지 않은 경우 
    - 저장해두었던 캐시를 재사용할 수 있습니다. 
- 위의 경우 확인을 위해 검증 헤더(last modified)가 필요합니다. 
  - 처음에 서버에서 리소스를 보낼 때, 헤더에 last modified 날짜를 함께 보내고, 클라이언트의 캐시 저장소에도 함께 저장되요.
  - 유효 기간이 지났을 경우 요청을 보낼 때는 last modified 날짜를 보내면서 이 리소스의 서버 갱신 여부를 확인 합니다. 
  - 만약 서버에서 갱신 되지 않았을 경우에는 서버가 304 Not modified 상태코드를 보내면서 헤더만 보냅니다 (바디는 보내지 않아요.)
  - 이제 응답을 받은 클라이언트의 웹 브라우저는 헤더를 읽고 아 이건 다시 쓰면 되는군! 하고 유효기간을 갱신하고 캐시저장소에서 리소스에 접근해서 사용합니다. 


## 검증 헤더와 조건부 요청2 

Last-modified 
- If-modified-Since : 이후 데이터가 수정되었는지 확인을 바라는 날짜 입니다. 
  - 미변경(False): 
    - 304 Not Modified 
  - 변경(True) : 
    - 200 OK
    - 헤더와 바디를 모두 서버에서 응답 합니다. 
  - 단점  
    - 초 미만 단위 조정 불가능 합니다. 
    - 날짜 기반 로직을 사용합니다. 
    - 실제 컨텐츠는 갱신 하지 않았지만, 원본을 수정한 경우(예 주석 변경) 에는 수정일 이 변경 되므로 다시 다운로드 해야합니다. 
  
ETag(If-None-Match == 컨텐츠가 변경 되었으면)
- 캐시용 데이터에 임의의 고유 버전 명을 달아두는 것 입니다. 
- 컨텐츠의 변경이 없다면 버전명이 계속 유지 됩니다. 

## 캐시와 조건부 요청 헤더
### 캐시 제어 헤더 
- Cache-Control : 캐시 제어 
  - max-age : 캐시 유효기간(초단위)
  - no-cache: 데이터는 캐시 해도 되지만, 항상 origin 서버에 검증하고(데이터가 유효한지) 사용 합니다. 
  - no-store : 민감한 정보가 있으므로 저장하면 안됩니다. no-cache와 헷갈리지말것! 
- Pragma : 캐시 제어 
  - no-cache 와 같은데, http 1.0 하위 호환 용 입니다. 
- Expires : 캐시 유효기간 
  - 캐시 만료일을 지정 합니다. pragma 처럼 하위호환 용입니다. 
  - 초단위가 아니라 일 단위 입니다. 경직 
  - max-age > Expires

## 프록시 캐시
- origin 서버 : 진짜 리소스를 처리 해서 응답하는 서버 
- 프록시 캐시는 클라이언트가 빠르게 접속 하게 하기 위해서 클라이언트가 가까이 있는 프록시 서버에 접속해서 응답을 받도록 해두고(private cache), 
- 프록시 서버와 원서버가 리소스를 주고 받도록 하는 것입니다. (public cache )

캐시 컨트롤 
- public : 프록시 캐시서버 에 저장되어도 되는 것 
- private : 로그인 정보 등 프록시 캐시 서버에 저장되면 안되는 것 
- s-maxage : 프록시 캐시 에만 적용되는 age 
- Age 
 
## 캐시 무효화
캐시 설정을 하지 않아도 웹브라우저가 임의로 캐시 할 수 있으므로, 
캐시 하면 절대 안되는 경우 명시적으로 선언(?) 해주어야 합니다. 

- Cache-Control : no-cache, no-store, must-revalidate 
  - must-revalidate :
    - 캐시 만료 후 최초 조회시 원 서버에서 검증 해야합니다. 
    - no-cache 와 비교 해서 왜 필요한지? 
      - 프록시 캐시 서버와 원서버 사이 연결 장애가 있을 때 
        - no-cache는 설령 만료 후 갱신이 되었을지라도 갱신 전 데이터라도 클라이언트가 받는 것이 낫다고 가정 하고 304 를 내려줍니다(?) 
        - must-revalidate 는 **504 에러 코드** 를 보내 줍니다. 
    
- Pragma : no-cache 

# 이 다음 학습은? 
- 실무에 필요한 것은 검색으로 습득 하되, 의심의 눈으로 자료를 볼 것! 
- 깊이 있는 학습? 
  - http 스펙 을 보자 
    - RFC 2616 은 보면 안됨 
    - RFC 7230 - 5 로 개정 되었으니, 이 것을 보아야함 
  - 백엔드 개발 
    - 웹 프레임워크 는 HTTP 기반으로 구현 되어 있어요. 
    - 웹 프레임워크의 기술을 강의에서 배운 내용을 토대로 깊이 있게 이해 해봅시다. 
