---
title: TIL 2021-09-30 JAVA 객체 지향 3번째 학습!
tags: [TIL, JAVA]
categories: TIL
---

- 먼저 클래스 생성에 대해 복습했습니다. 
- 각 변수 타입 별 인자 값과 리턴 값이 어떻게 되는가! 데이터가 어떻게 넘겨지고 메모리에 올라가는지에 대해 배웠습니다. 
    - 기본 데이터형은 변수에 바로 데이터가 저장되므로,메소드에 인자로 넘어가게되면 데이터가 메소드의 stack영역에 복사됩니다. 따라서 메소드에서 추가적인 연산을 하더라도 메인의 stack 영역에 있는 해당 변수의 데이터 값에는 영향을 주지 않습니다. 
    - 참조 데이터형의 경우에는 변수에 해당 데이터의 주소값이 저장됩니다. 메소드의 인자로 넘어가게되면 주소 값이 복사되게 되고 해당 메소드의 stack영역에서 heap영역에 있는 데이터에 접근하게 됩니다. 그래서 메소드 안에서 데이터를 변경하게 되면, 해당 변수의 데이터 값이 변경되게 됩니다. 
    - 메소드에서 형성된 변수(int)를 리턴하여 다시 메인의 stack영역에서 쓰기 위해선 변수를 선언하고 리턴 값을 저장하여야 합니다. 
    - 메소드에서 형성된 변수 (배열)을 리턴할 수도 있습니다. 다만 이경우에도 배열을 선언하고 리턴 값을 저장하여야 합니다. 
    - 객체도 메소드의 인자가 될 수 있다는 것을 배웠습니다.메인메소드에서 객체를 선언하여 생성한 후, 메소드를 호출 할 수 있고, 메소드를 통해 데이터를 처리 할 수 있습니다.
    - 뿐만 아니라 메소드에서 객체를 생성해서 리턴할 수 도 있습니다. 메소드 호출로서 heap영역에 객체가 생성되고, 객체의 주소값을 리턴하게 하여, 메인메소드에서 객체의 주소값을 저장하게 하면 메소드를 나온 후에도 계속 객체에 접근할 수 있습니다. 

    - => 결론은 기본데이터형은 변수에 데이터 자체가 저장되고, stack 메모리에 저장되지만 참조 데이터 형은 주소 값을 복사하고 리턴하므로, heap 메모리 공간에 있는 데이터를 직접 건든다. 주소값을 저장하면 계속 접근 가능하다.라고 생각하니까 덜 헷갈리는 것 같습니다. 


- new 클래스()를 하면 메모리 영역에서 생기는 일에 대해 공부 했습니다. 
    - 1. heap 메모리에 멤버변수생성 / code 영역에 메소드 생성 
    - 2. 생성자 호출 

- 생성자란
    - 1. new로 객체 생성시 자동으로 호출되는 메소드입니다.
            - 예외 : 생성자 안에서 다른 생성자를 호출 할 수 있다.
    - 2. 메소드의 멤버 변수를 초기화하는 기능을 합니다.
    - 3. 선언시 리턴 타입을 지정하지 않습니다.
    - 4. 선언시 이름은 클래스 이름과 동일하게 지정 해야합니다.
    - 모든 자바 클래스는 반드시 한개 이상의 생성자를 갖습니다. 지정하지 않은 경우에도 컴파일시 자동으로 생성된다고 합니다. 
    - 다만, 하나의 생성자라도 있다면 자동으로 생성되지 않습니다. 생성자의 기본 형태는 인자를 받지 않는 것인데, 기본형태의 생성자가 작성되지 않는 것입니다. 만약 생성자를 직접 작성할 때 인자를 받도록 하였는데 기본형태의 생성자를 작성해두지 않았다면, 메소드를 사용할 때 인자를 받지 않도록 하였을 때 오류가 납니다. 

- 생성자 선언 
    - 멤버변수 선언 영역 과 메소드 선언 영역 사이에 선언합니다.
    - 메소드 형태를 가져야 합니다.
    - 리턴 타입을 주지 않습니다.
    - 클래스 이름과 동일 해야 합니다.



- 생성자 역시 인자를 넣는 것이 가능하며, 오버로딩도 가능 합니다. 
    - 다만 객체 지향, 유지 보수성을 높이기 위해서 객체화 와 중복코드 금지가 필요 한데, 오버로딩시 발생하는 중복 코드를 제거하는 리팩토링에 대해서 배웠습니다.
- 리팩토링 
```java 
    // 생성자 선언을 해보자
    // 리팩토링
    public Student(){ //기본 생성자
        this("00000000");
    }
    public Student(String stdId){
        this(stdId,"Anonyous");
    }
    public Student(String stdId,String name){
        this(stdId,name,"미정");
    }
    public Student(String stdId,String name,String major){
        this.stdId = stdId;
        this.name = name;
        this.major = major;
```

-  제어자 static
    - 선언하면 생기는 일
        - static 변수는 프로그램 시작할 때 code 영역에 생성됩니다. 처음 단 한번만 생성되며 인스턴스 생성시 다시 생성되지 않고,해당 인스턴스에는 변수의 code 영역의 주소값만 들어갑니다. 따라서 모든 인스턴스가 동일한 변수를 사용합니다. 
    - 모든 객체가 공통으로 사용할 데이터의 경우에는 static을 사용합니다. 그래서 클래스 변수라고도 합니다. 
    - static은 변수 뿐 아니라 메소드에도 사용할 수 있습니다.역시 범용적으로 사용할 메소드에 대해 사용합니다. 
    - static 블럭을 사용할 수도 있습니다.  프로그램 시작 전에 전처리 작업할 때 영역을 지정하고 미리 처리 하도록 할 수 있습니다. 
-이제는 public static void main(String[] args) 를 이해할 수 있게 되었습니다. main 메소드 영역은 java SE에서 프로그램을 실행하였을 때 가장 먼저 실행되는 영역입니다. public 이므로 접근 제한 없이 모든 곳에서 접근 할 수 있고, static이므로 프로그램 실행시 부터 생성되며, void 이므로 리턴 값을 받지 않습니다. 마지막으로 메인 메소드는 (String[] args)으로 되어있으므로 배열을 인자로 받을 수 있습니다. 

