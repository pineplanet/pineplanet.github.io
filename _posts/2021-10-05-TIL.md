---
title: TIL 2021-10-05 JAVA 다형성!
tags: [TIL, JAVA]
categories: TIL
---
## 👀 오늘 배운 것 

- 다형성 개념 복습 
    - 오늘은 다형성에 대해 복습을 먼저 했습니다. 상속관계를 다루기 위한 방법 중 하나 인데요. 부모 와 자식간 1:1 관계 뿐만 아니라 부모와 `여러 자식`들의 관계를 쉽게 다를 수 있는 개념 입니다. 개념이 모호해서 한 문장으로 정의 하기 어려웠습니다.네이버 사전으로 검색하니 poly(하나 이상), morph(형태)가 합성된 단어로 '하나 이상의 형태'를 뜻합니다. 한가지 이름의 메소드인데 여러 동작을 하도록 하는게 다형성 인가봐요. 
    - 상속관계에서 다형성의 이용
        - 오늘까지 배운 바로는 자식들은 자신의 클래스 뿐 아니라 상속을 통해 부모의 클래스도 가지고 있어요. 이렇게 여러 타입을 가지고 있는 속성을 이용하는 것도 다형성 입니다. 
        - 저는 앱등이니까 `아이폰`으로 예를 들어 이해를 해보자면(이 예는 완전히 틀린 걸 수도 있으므로, 나중에 개념이 완벽해지면 변경될 예정), 이번에 나오는 `아이폰 13`은 `아이폰 13`, `아이폰 13 프로`,`아이폰 13 프로 맥스`,`아이폰 13 미니`가 있습니다. 우리가 아이폰을 사려한다면 각각 모델들을 하나씩 하나씩 사양을 확인하고 선택할 수도 있지만, 편리하고 쉽게 비교하기 위해 이번 시즌에 나온 아이폰을 `전부 모아놓고` 어떻게 `다른지 비교`를 할거에요. 일단 다 다른 객체 지만 아이폰 13 이라는 속성을 가지고 있으니, 이 속성으로 일단 모아놓고, 개별적인 객체의 특성에 따라 처리할 수 있습니다. 
        - 그리고 이번에는 `아이폰 케이스 장인`에 빙의 해서 보면, 아이폰은 모델 마다 크기와 카메라 갯수가 달라요. `같은 상품`을 만들어서 소재와 색깔은 같아도 `서로 다른 틀`을 사용해야 합니다. 각 모델마다 따로 따로 공정을 설계하고 설비할 수 도 있지만, 공정을 표준화해서 생산라인은 동일하게 하되 찍어내는 틀과 세부 공정만 조정할 수도 있어요.
        - 요약: 업캐스팅과 다운 캐스팅을 이용하여 형제 클래스를 공통적인 조상 클래스의 타입으로 묶어서 하나의 메소드로 처리 할 수 있다. 그리고 각 클래스 내부에 동일한 이름의 메소드들을 오버라이딩해서 쓸 수 있다. 

- 추상 메소드의 복습 
    - 추상 메소드(abstract)란 부모가 가진 메소드를 자식이 무조건 `오버라이딩하게 강제`하는 것 입니다. {구현부}를 넣지 않고,선언부만 만들어요. 사실 자식이 메소드를 무조건 구현하도록 강제한다는 의미 외에는 왜 굳이 이렇게 하나 라는 생각도 드는데, 모든 자식들이 가지고 있어야할 공통된 메소드 이지만, 내부 동작은 미묘하게 다른 부분이 있을 수도 있으니 일단 미완성 상태로 만들어놓고 자식에게 넘겨서  `객체 지향 - 유지 보수성 `을 강화 하기 위한 것 같아요. 
    - 모습 : 부모 바디 없이 + abstract + 클래스에도 abstract, 자식 클래스도 완성되지 않은 경우 abstact 를 사용하여 그 다음 자식에게 오버라이딩 의무를 넘길 수 도 있다. 
    - 추상 메소드는 오늘 배운 인터페이스와 연결 됩니다. 추상 메소드 중에서 조건에 맞는 경우 인터페이스 를 만들 수 있어요. 
        - 여기서 조건은 클래스의 모든 메소드들이 `추상 메소드`이고, 모든 멤버변수들이 `public static final`인 경우 여야 합니다. 
        - 이런 경우 interface 예약어를 사용하여 abstract나 public static final 등의 예약어를 생략할 수 가 있어요. 

- 인터페이스 
    - 인터페이스는 앞서 배운 다형성과 추상메소드를 이용해서 공통 된 부분은 `통일` 하여 `표준 약속` 을 정하는 것으로서 자바의 `객체 지향, 유지 보수성`을 극대화 시키는 기능 입니다(?). 
    - 여러 객체들이 공통으로 사용할 변수나 메소드들의 명칭과 기능(?결과물)만 미리 정해두고, 실제 내용은 자식 클래스가 오버라이딩 하여 구현하게 합니다. 그러면 클래스들이 어떻게 구현되는지는 달라도 `이름과 기능은 같아`집니다. 
    - 이렇게 해두면 객체 지향 시스템을 구축할 수 있게 되고, 시스템을 변경해야할 때도 만들어진 코드의 내용을 많이 바꿀 필요 없이 간단하게 변경할 수 있게 됩니다. 인터페이스만 보고서 개발을 할 수 도 있어요. 
    - 예를 들어 TV라는 인터페이스를 만들어서 각 변수와 메소드 명칭을 미리 정해둔 다음에 LG Tv 클래스를 만들어 봅시다. 그리고 LG TV 인스턴스를 만들어서 티비를 껐다 켰다 볼륨을 올렸다 내렸다 할 거에요.
        ```java
        public interface TV {
            public void turnOn();
            public void turnOff();
            public void soundUp();
            public void soundDown();
        }
        ```
    
        ```java
        class LGTV implements TV {
            @Override
            public void turnOn() {
                System.out.println("LGTV -- 켠다");
            }

            @Override
            public void turnOff() {
                System.out.println("LGTV -- 끈다");
            }

            @Override
            public void soundUp() {
                System.out.println("LGTV -- 소리를 올린다");
            }

            @Override
            public void soundDown() {
                System.out.println("LGTV -- 소리를 내린다");
            }
        }
        ```
    - 이렇게 클래스를 다 만들고, main 메소드안에서 호출하는 것 까지 다 짰는데 선생님이 갑자기 Samsung TV 로 변경하라고 합니다. 그러면 킹받을 필요 없이 LG TV 클래스를 고대로 카피 떠서 LG 이라고 되있는 부분만 삼성으로 바꾸고, 추가될 부분만 넣어 놓고 main 메소드안에도 Samsung으로 바꾸면 됩니다. 여러가지 손 댈 필요 없이 변경 할 수 있어요.

    - 인터페이스의 상속(implement) : 클래스 간 상속은 extends라는 키워드를 사용하지만 클래스가 인터페이스를 상속하는 경우에는 implement를 사용합니다(인터페이스가 인터페이스를 상속하는 경우엔 extends를 사용해요).
        - 상속을 하게 되면 자식 클래스는 인터페이스에서 선언된 메소드를 완성(오버라이딩)할 의무가 생깁니다.그런데 이때 자식 클래스가 abstract를 선언하면 다른 클래스가 이 자식 클래스를 상속받아 메소드를 완성하도록 넘길 수도 있습니다. 
        - 인터페이스에 완성된 메소드를 넣으면 어떻게 될까 궁금해서 넣어봤더니 에러가 납니다.        
            - 메소드의 바디를 넣지 않는 것이 원칙 인데,
            - 제어자(default/static/private 등 )가 있는 경우에는 바디를 넣을 수도 있다고 합니다.
        - 다중 상속 가능 : 클래스의 경우에는 단일 상속만 가능하지만, 인터페이스의 경우에는 다중 상속할 수 있습니다. 
            - 모습 : 
                - 하나의 클래스가 여러  인터페이스를 상속 받을 수도 있고, 
                - 하나의 클래스가 인터페이스와 함께 클래스를 상속 받을 수도 있습니다. 
                - 또한 인터페이스가 인터페이스를 상속 받을 수 도 있습니다. 
                - 예 : `class Bird` extends` Animal` implements` Flyer`, interface `Vehicle2`{}
                    - Bird 클래스는 Animal 클래스와 
                    - Flyer, Vehicle2 인터페이스를 상속 받고 있습니다. 
                - 클래스가 인터페이스를 상속 받을 때는 implements를 사용하는데,
                - 인터페이스가 인터페이스를 상속 받을 때는 extends를 사용합니다. 
        - 다이어그램으로 표시는 어떻게 하는가? 
            - 클래스간 상속관계는 실선으로 표시 되는데 
            - 인터페이스의 상속관계는 점선으로 표시 됩니다. 
- 팩토리 디자인 패턴 
    - 인터페이스를 사용하면 코드의 변경을 쉽고 간단하게 할 수 있다고 했는데, 이 경우에도 인스턴스의 생성 코드를 변경 해야합니다. 이마저도 하기 싫은 경우 팩토리 디자인 패턴을 사용할 수 있습니다. 특히 웹 개발할 때 스프링을 사용한다고 하는데 팩토리 디자인 패턴을 사용하기 때문에 지금 배운 것을 기억해 두면 좋다고 합니다. 
    - 패턴 예제: 위에서 인터페이스를 공부하면서 TV를 만들어 보았는데요. 이 코드들에 팩토리 디자인 패턴을 추가하여 공부했습니다. 
        - 인터페이스와 SamsungTv, LG TV 클래스 파일은 그대로 두고, 
        - 아래와 같이 class BeanFactory 코드를 작성 하였습니다. 
            ```java
            public class BeanFactory {
                public Object getBean(String name){
                    Object obj = null;

                    if(name.equals("samsung")){
                        obj= new SamsungTV();
                    }else if (name.equals("lg")){
                        obj = new LGTV();
                    }
                return obj;

                }
            }
            ```
        - 그리고 main 메소드가 있는 파일을 작성 하였습니다.
            ```java
                public class Test{
                    public static void main(String[] args) {
                        //LGTV tv = new LGTV();
                        //다형성을 해보자
                        //TV tv = new SamsungTV();
                        //팩토리 패턴 이용해보자
                        BeanFactory factory = new BeanFactory();
                        //TV tv = (TV)factory.getBean(args[0]);
                        TV tv = (TV)factory.getBean("lg");
                        tv.turnOn();
                        tv.soundUp();
                        tv.soundDown();
                        tv.turnOff();
                        // 오버라이딩한 메소드가 실행 되니까, 타입변경 안해도 됨
                    }
                }
            ```
        - 위의 코드의 경우 TV 클래스를 변경할 때는 getBean("lg")의 lg만 변경하면 클래스가 변경 됩니다. 

- 상속 에 대한 문제 풀이를 했습니다. 

## 🥳오늘 느낀 것 
자바를 처음 배울 때는 형식적이고 번거로운, 자유롭지 못한 언어라고 생각했는데, 오늘 까지 자바를 공부하면서는 자바가 굉장히 체계적이고 친절(?)하다는 느낌이 들었습니다. 그리고 자바의 모든 기능은 결국 객체 지향이라는 방향으로 수렴하는구나. 하는 생각이 들었습니다. 

문법이 익숙하지 않고, 많은 알고리즘 풀이(?)방법을 모르는 것은 일단 언젠가는 해결해야할 것이지만, 자바의 객체 지향 관련된 내용을 반복학습하면서 아는 부분을 확장해가야겠다는 생각이 들었습니다. 
        


